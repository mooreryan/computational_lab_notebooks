{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Computational Lab Notebooks Documentation for installing and using cln , a command line program to help you set up and manage a computational lab notebook using git and git-annex. It's inspired by Rails ActiveRecord migrations , in that it helps you prepare, run, and commit actions. This documentation is a work in progress. For suggestions, corrections, and pull-requests, please visit the issue tracker or the documentaion GitHub repository . License Software The cln program is licensed under the Apache License, Version 2.0 or the MIT license, at your option. This program may not be copied, modified, or distributed except according to those terms. You can view the license files here: MIT and Apache v2.0 . Documentation \u00a9 Ryan Moore, 2021. This work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License .","title":"Computational Lab Notebooks"},{"location":"#computational-lab-notebooks","text":"Documentation for installing and using cln , a command line program to help you set up and manage a computational lab notebook using git and git-annex. It's inspired by Rails ActiveRecord migrations , in that it helps you prepare, run, and commit actions. This documentation is a work in progress. For suggestions, corrections, and pull-requests, please visit the issue tracker or the documentaion GitHub repository .","title":"Computational Lab Notebooks"},{"location":"#license","text":"","title":"License"},{"location":"#software","text":"The cln program is licensed under the Apache License, Version 2.0 or the MIT license, at your option. This program may not be copied, modified, or distributed except according to those terms. You can view the license files here: MIT and Apache v2.0 .","title":"Software"},{"location":"#documentation","text":"\u00a9 Ryan Moore, 2021. This work is licensed under Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License .","title":"Documentation"},{"location":"git/","text":"Just Enough Git The cln app helps you manage your computational lab notebook with git and git-annex . While you still need to know some things about git and git-annex, you don't need too much -- as long as you're comfortable with some of the fundamentals, you should be good. Everyday Commands Let's go through some everyday git commands . /tmp/example$ git --version git version 2.27.0 How to get help To get a basic overview of command git commands: $ git help ...prints out the help screen... For more detailed help, use $ git help -a ...lots and lots of commands... To get help with a specific commands do something like this: $ git help add ...shows help page for git-add $ git help checkout ...shows help page for git-checkout To get help with some of the most common git commands, run this: $ git help everyday ...shows useful commands... Basic git workflow Let's run through a basic example git workflow. In this example, I will make a new project (git repository), make a README.md , make some fake reads in a fasta file, do some silly \"quality control\". Lines that start with $ are commands that I ran. Initialize a new git repository. $ git init Initialized empty Git repository in /tmp/example/.git/ Make a README file. $ printf \"# My Cool Project > > This willl be a really fun project > \" > README.md Add readme file contents to the \"index\". $ git add README.md Commit changes with message. $ git commit -m \"Initial commit\" [master (root-commit) d93d073] Initial commit 1 file changed, 3 insertions(+) create mode 100644 README.md Create and switch to a new branch called make-seqs. $ git checkout -b make-seqs Switched to a new branch 'make-seqs' Make a fasta file. $ printf \">seq1 > ACTG > >seq2 > actg > \" > seqs.fa Add the fasta file to the index. $ git add seqs.fa Commit the changes with a message. $ git commit -m \"Make a fake seqs file\" [make-seqs 0748c17] Make a fake seqs file 1 file changed, 4 insertions(+) create mode 100644 seqs.fa Switch back to the master branch. $ git checkout master Switched to branch 'master' Merge the changes in the make-seqs branch into the master branch. $ git merge make-seqs Updating d93d073..0748c17 Fast-forward seqs.fa | 4 ++++ 1 file changed, 4 insertions(+) create mode 100644 seqs.fa Delete the make-seqs branch. $ git branch -d make-seqs Deleted branch make-seqs (was 0748c17). Create and switch to a new branch called qc. $ git checkout -b qc Switched to a new branch 'qc' Do some (fake) \"quality control\". $ tr \"a\" \"N\" < seqs.fa > seqs.qc.fa Add the changes/new file to the index. $ git add seqs.qc.fa Commit the changes with the given message. $ git commit -m \"Run read QC\" [qc 6a8f070] Run read QC 1 file changed, 4 insertions(+) create mode 100644 seqs.qc.fa Check the log to see what we have done. $ git log --pretty=oneline 6a8f070741e083de38cee9498123c984ee33d514 (HEAD -> qc) Run read QC 0748c17a80587f1e9f5832a1966c6d1ddb9960de (master) Make a fake seqs file d93d0735c7b05c5d69e80c5c68926e12be1744d8 Initial commit Switch back to the master branch. $ git checkout master Switched to branch 'master' Okay, that quality control wasn't very good, just delete the qc branch like it never happened. $ git branch -D qc Deleted branch qc (was 6a8f070). Check the log...the \"quality control\" step is gone! $ git log --pretty=oneline 0748c17a80587f1e9f5832a1966c6d1ddb9960de (HEAD -> master) Make a fake seqs file d93d0735c7b05c5d69e80c5c68926e12be1744d8 Initial commit See...just readme and sequences. $ ls README.md seqs.fa It's the file we made. $ cat seqs.fa >seq1 ACTG >seq2 actg What is an \"index\"? Here is what the git-add help file says about the \"index\": The \"index\" holds a snapshot of the content of the working tree, and it is this snapshot that is taken as the contents of the next commit. Thus after making any changes to the working tree, and before running the commit command, you must use the add command to add any new or modified files to the index. git-add followed by more edits If you run git add some_file.txt , then change the contents of some_file.txt again before commiting the changes, those new changes will not be reflected in the repository unless you run git add some_file.txt again before commiting. Here is an example of what I mean: Edit the seqs file with nano. $ nano seqs.fa Show the difference from last commit. I edited the first sequence name. Lines that change have a - indicated the old version and a + indicated the new change. $ git diff seqs.fa diff --git a/seqs.fa b/seqs.fa index 60129d5..53d21e0 100644 --- a/seqs.fa +++ b/seqs.fa @@ -1,4 +1,4 @@ ->seq1 +>seq1_best_sequence ACTG >seq2 actg Add the changes to the index. $ git add seqs.fa Check the status. The changes are now staged for the commit. $ git status On branch master Changes to be committed: (use \"git restore --staged <file>...\" to unstage) modified: seqs.fa Edit the file again. $ nano seqs.fa Show the differences again. I edited the second sequence name. $ git diff seqs.fa diff --git a/seqs.fa b/seqs.fa index 53d21e0..c89e2ff 100644 --- a/seqs.fa +++ b/seqs.fa @@ -1,4 +1,4 @@ >seq1_best_sequence ACTG ->seq2 +>seq2_2nd_best actg Commit the staged changes (still just the first name change!) $ git commit -m \"Edit the seqs file\" [master c5c5681] Edit the seqs file 1 file changed, 1 insertion(+), 1 deletion(-) Check status. See how there are still changes not staged for commit? That's because git add stages changes at the time you ran git-add . $ git status On branch master Changes not staged for commit: (use \"git add <file>...\" to update what will be committed) (use \"git restore <file>...\" to discard changes in working directory) modified: seqs.fa no changes added to commit (use \"git add\" and/or \"git commit -a\") The changes are still there in the file though. $ cat seqs.fa >seq1_best_sequence ACTG >seq2_2nd_best actg Check the difference. See how the 2nd header is different? $ git diff seqs.fa diff --git a/seqs.fa b/seqs.fa index 53d21e0..c89e2ff 100644 --- a/seqs.fa +++ b/seqs.fa @@ -1,4 +1,4 @@ >seq1_best_sequence ACTG ->seq2 +>seq2_2nd_best actg Add the current changes to the index. $ git add seqs.fa Commit the changes. $ git commit -m \"Change 2nd header\" [master 9454d4e] Change 2nd header 1 file changed, 1 insertion(+), 1 deletion(-) Check the status...the working tree is clean, all changes have been commited. $ git status On branch master nothing to commit, working tree clean Git Branches Git has branches to help you keep work isolated. You generally have a main branch called master or main . This is the \"main\" branch in the sense that it is the main access point for your repository or project. You can do all your work in the main branch, but if you make mistakes and need to roll back any changes, it can be harder than if you do all of your work in a separate branch (i.e., a \"working\" branch). Let's see a little example to show you what I mean. Create a new git repo Make a new git repository, add and commit an example text file. $ mkdir example && cd example $ git init $ printf \"hello, world\\n\" > hello.txt $ git add . && git commit -m \"Initial commit\" Check the current branch. $ git branch * master See how we are on the master branch to start with? Now, let's create and switch to a new branch. Create a new branch and do some work $ git checkout -b edit-hello Switched to a new branch 'edit-hello' And now when we run git branch you can see we are on a different branch. $ git branch * edit-hello master Edit the file in the work branch Now we will edit the hello.txt file in the new edit-hello branch we just created. $ sed -i 's/l/L/g' hello.txt That's the sed command. If you haven't seen it, it is a stream editor. All that command does is change every l to a L in the file. Now check the status of the repository. $ git status On branch edit-hello Changes not staged for commit: (use \"git add <file>...\" to update what will be committed) (use \"git restore <file>...\" to discard changes in working directory) modified: hello.txt no changes added to commit (use \"git add\" and/or \"git commit -a\") It says that the hello.txt file has changed. Let's check the changes now. $ git diff hello.txt diff --git a/hello.txt b/hello.txt index 4b5fa63..09d7e19 100644 --- a/hello.txt +++ b/hello.txt @@ -1 +1 @@ -hello, world +heLLo, worLd We can see that hello, world is now heLLo, worLd . That's what we wanted so now we can commit the changes. Commit the changes in the work branch $ git add hello.txt $ git commit -m \"Swich lowercase 'l' to uppercase 'L'\" [edit-hello 27e542d] Swich lowercase 'l' to uppercase 'L' 1 file changed, 1 insertion(+), 1 deletion(-) Just double check that the git repository is clean now. $ git status On branch edit-hello nothing to commit, working tree clean How has our repository changed So now we've done some work on the edit-hello branch, let's switch back to the master branch and see check the state of the repository. $ git checkout master Switched to branch 'master' $ git status On branch master nothing to commit, working tree clean $ cat hello.txt hello, world Whoa! The hello.txt file is the same as it was before we switched branches and did all those changes. Let's check the log. git log --pretty=oneline 8a5b9042705aff008dc396b385a3f03200e79647 (HEAD -> master) Initial commit See how that last commit isn't even listed? Let's go back to the edit-hello branch and check the log there. $ git checkout edit-hello Switched to branch 'edit-hello' $ git log --pretty=oneline 27e542d2192c3b1807f14b2460118045d549d7f5 (HEAD -> edit-hello) Swich lowercase 'l' to uppercase 'L' 8a5b9042705aff008dc396b385a3f03200e79647 (master) Initial commit Okay, both commits are still there. Notice how the commit at the top says (HEAD -> edit-hello) whereas the first commit says (master) ? This is telling you that the commits are specific to certain branches. Just to reinforce this, we will switch back to master and look at the logs again. $ git checkout master Switched to branch 'master' $ git log --pretty=oneline 8a5b9042705aff008dc396b385a3f03200e79647 (HEAD -> master) Initial commit Back to one commit with (HEAD -> master) . And one more time, back to edit-hello branch. $ git checkout edit-hello Switched to branch 'edit-hello' $ git log --pretty=oneline 27e542d2192c3b1807f14b2460118045d549d7f5 (HEAD -> edit-hello) Swich lowercase 'l' to uppercase 'L' 8a5b9042705aff008dc396b385a3f03200e79647 (master) Initial commit What to do with the changes? Now we have two options. I like the changes in the edit-hello branch and want to make them part of the master branch. I don't like the changes in the edit-hello branch and want to forget about them. Keep the changes in the work branch For the first, I need to merge the changes in the edit-hello branch into the master branch. Let's do that now. $ git branch * edit-hello master $ git checkout master Switched to branch 'master' $ git branch edit-hello * master $ git merge edit-hello Updating 8a5b904..27e542d Fast-forward hello.txt | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) $ git status On branch master nothing to commit, working tree clean $ git log --pretty=oneline 27e542d2192c3b1807f14b2460118045d549d7f5 (HEAD -> master, edit-hello) Swich lowercase 'l' to uppercase 'L' 8a5b9042705aff008dc396b385a3f03200e79647 Initial commit $ cat hello.txt heLLo, worLd See how the second commit is now in the git log and see how the hello.txt file has the changes? Since the changes are fully merged, we can safely delete the edit-hello branch. $ git branch -d edit-hello Deleted branch edit-hello (was 27e542d). $ git branch * master And now the edit-hello branch is gone. Get rid of the changes in the work branch What about the second option. Let's say we don't really like the changes of the edit-hello branch, and we just want to get rid of them. In that case we delete the branch without first merging the changes. (Note that the hash values have changed. That's because, for this tutorial, I just deleted the whole repository and started over rather than bother rolling back the changes like I would do in a real repository.) First, make sure you are on the master branch. $ git checkout master Already on 'master' $ git branch edit-hello * master Then delete the edit-hello branch. $ git branch -d edit-hello error: The branch 'edit-hello' is not fully merged. If you are sure you want to delete it, run 'git branch -D edit-hello'. See the error you got? This is because there are changes present in the edit-hello working branch that are not currently part of the master branch. So if you were to delete the edit-hello branch now, you would lose those changes with no way to get them back. Since this is actually what we want to do, we will follow the instructions on the screen and use the -D flag instead of -d to force deletion of the edit-hello branch. $ git branch -D edit-hello Deleted branch edit-hello (was cc722a5). $ git branch * master $ git log --pretty=oneline f15b723b204deb59b1f23577439ec58d917b2269 (HEAD -> master) Initial commit $ cat hello.txt hello, world As you see, we are back to the initial commit as though all of the work on the edit-hello branch never happened. Wrap up Git branches are a powerful technique for isolating work in such a way that you can test things out without worrying about \"messing up\" your repository. Then, when you've finished the task you're working on, if it is good work, you can merge the changes into the master branch, or, if it was bad, you can just delete the working branch without applying any of the changes to the master branch. Notes Notice how I named the work branch with a short description of what I was actually planning to do? This can be helpful if you have a lot of different branches.","title":"Just Enough Git"},{"location":"git/#just-enough-git","text":"The cln app helps you manage your computational lab notebook with git and git-annex . While you still need to know some things about git and git-annex, you don't need too much -- as long as you're comfortable with some of the fundamentals, you should be good.","title":"Just Enough Git"},{"location":"git/#everyday-commands","text":"Let's go through some everyday git commands . /tmp/example$ git --version git version 2.27.0","title":"Everyday Commands"},{"location":"git/#how-to-get-help","text":"To get a basic overview of command git commands: $ git help ...prints out the help screen... For more detailed help, use $ git help -a ...lots and lots of commands... To get help with a specific commands do something like this: $ git help add ...shows help page for git-add $ git help checkout ...shows help page for git-checkout To get help with some of the most common git commands, run this: $ git help everyday ...shows useful commands...","title":"How to get help"},{"location":"git/#basic-git-workflow","text":"Let's run through a basic example git workflow. In this example, I will make a new project (git repository), make a README.md , make some fake reads in a fasta file, do some silly \"quality control\". Lines that start with $ are commands that I ran. Initialize a new git repository. $ git init Initialized empty Git repository in /tmp/example/.git/ Make a README file. $ printf \"# My Cool Project > > This willl be a really fun project > \" > README.md Add readme file contents to the \"index\". $ git add README.md Commit changes with message. $ git commit -m \"Initial commit\" [master (root-commit) d93d073] Initial commit 1 file changed, 3 insertions(+) create mode 100644 README.md Create and switch to a new branch called make-seqs. $ git checkout -b make-seqs Switched to a new branch 'make-seqs' Make a fasta file. $ printf \">seq1 > ACTG > >seq2 > actg > \" > seqs.fa Add the fasta file to the index. $ git add seqs.fa Commit the changes with a message. $ git commit -m \"Make a fake seqs file\" [make-seqs 0748c17] Make a fake seqs file 1 file changed, 4 insertions(+) create mode 100644 seqs.fa Switch back to the master branch. $ git checkout master Switched to branch 'master' Merge the changes in the make-seqs branch into the master branch. $ git merge make-seqs Updating d93d073..0748c17 Fast-forward seqs.fa | 4 ++++ 1 file changed, 4 insertions(+) create mode 100644 seqs.fa Delete the make-seqs branch. $ git branch -d make-seqs Deleted branch make-seqs (was 0748c17). Create and switch to a new branch called qc. $ git checkout -b qc Switched to a new branch 'qc' Do some (fake) \"quality control\". $ tr \"a\" \"N\" < seqs.fa > seqs.qc.fa Add the changes/new file to the index. $ git add seqs.qc.fa Commit the changes with the given message. $ git commit -m \"Run read QC\" [qc 6a8f070] Run read QC 1 file changed, 4 insertions(+) create mode 100644 seqs.qc.fa Check the log to see what we have done. $ git log --pretty=oneline 6a8f070741e083de38cee9498123c984ee33d514 (HEAD -> qc) Run read QC 0748c17a80587f1e9f5832a1966c6d1ddb9960de (master) Make a fake seqs file d93d0735c7b05c5d69e80c5c68926e12be1744d8 Initial commit Switch back to the master branch. $ git checkout master Switched to branch 'master' Okay, that quality control wasn't very good, just delete the qc branch like it never happened. $ git branch -D qc Deleted branch qc (was 6a8f070). Check the log...the \"quality control\" step is gone! $ git log --pretty=oneline 0748c17a80587f1e9f5832a1966c6d1ddb9960de (HEAD -> master) Make a fake seqs file d93d0735c7b05c5d69e80c5c68926e12be1744d8 Initial commit See...just readme and sequences. $ ls README.md seqs.fa It's the file we made. $ cat seqs.fa >seq1 ACTG >seq2 actg","title":"Basic git workflow"},{"location":"git/#what-is-an-index","text":"Here is what the git-add help file says about the \"index\": The \"index\" holds a snapshot of the content of the working tree, and it is this snapshot that is taken as the contents of the next commit. Thus after making any changes to the working tree, and before running the commit command, you must use the add command to add any new or modified files to the index.","title":"What is an \"index\"?"},{"location":"git/#git-add-followed-by-more-edits","text":"If you run git add some_file.txt , then change the contents of some_file.txt again before commiting the changes, those new changes will not be reflected in the repository unless you run git add some_file.txt again before commiting. Here is an example of what I mean: Edit the seqs file with nano. $ nano seqs.fa Show the difference from last commit. I edited the first sequence name. Lines that change have a - indicated the old version and a + indicated the new change. $ git diff seqs.fa diff --git a/seqs.fa b/seqs.fa index 60129d5..53d21e0 100644 --- a/seqs.fa +++ b/seqs.fa @@ -1,4 +1,4 @@ ->seq1 +>seq1_best_sequence ACTG >seq2 actg Add the changes to the index. $ git add seqs.fa Check the status. The changes are now staged for the commit. $ git status On branch master Changes to be committed: (use \"git restore --staged <file>...\" to unstage) modified: seqs.fa Edit the file again. $ nano seqs.fa Show the differences again. I edited the second sequence name. $ git diff seqs.fa diff --git a/seqs.fa b/seqs.fa index 53d21e0..c89e2ff 100644 --- a/seqs.fa +++ b/seqs.fa @@ -1,4 +1,4 @@ >seq1_best_sequence ACTG ->seq2 +>seq2_2nd_best actg Commit the staged changes (still just the first name change!) $ git commit -m \"Edit the seqs file\" [master c5c5681] Edit the seqs file 1 file changed, 1 insertion(+), 1 deletion(-) Check status. See how there are still changes not staged for commit? That's because git add stages changes at the time you ran git-add . $ git status On branch master Changes not staged for commit: (use \"git add <file>...\" to update what will be committed) (use \"git restore <file>...\" to discard changes in working directory) modified: seqs.fa no changes added to commit (use \"git add\" and/or \"git commit -a\") The changes are still there in the file though. $ cat seqs.fa >seq1_best_sequence ACTG >seq2_2nd_best actg Check the difference. See how the 2nd header is different? $ git diff seqs.fa diff --git a/seqs.fa b/seqs.fa index 53d21e0..c89e2ff 100644 --- a/seqs.fa +++ b/seqs.fa @@ -1,4 +1,4 @@ >seq1_best_sequence ACTG ->seq2 +>seq2_2nd_best actg Add the current changes to the index. $ git add seqs.fa Commit the changes. $ git commit -m \"Change 2nd header\" [master 9454d4e] Change 2nd header 1 file changed, 1 insertion(+), 1 deletion(-) Check the status...the working tree is clean, all changes have been commited. $ git status On branch master nothing to commit, working tree clean","title":"git-add followed by more edits"},{"location":"git/#git-branches","text":"Git has branches to help you keep work isolated. You generally have a main branch called master or main . This is the \"main\" branch in the sense that it is the main access point for your repository or project. You can do all your work in the main branch, but if you make mistakes and need to roll back any changes, it can be harder than if you do all of your work in a separate branch (i.e., a \"working\" branch). Let's see a little example to show you what I mean.","title":"Git Branches"},{"location":"git/#create-a-new-git-repo","text":"Make a new git repository, add and commit an example text file. $ mkdir example && cd example $ git init $ printf \"hello, world\\n\" > hello.txt $ git add . && git commit -m \"Initial commit\" Check the current branch. $ git branch * master See how we are on the master branch to start with? Now, let's create and switch to a new branch.","title":"Create a new git repo"},{"location":"git/#create-a-new-branch-and-do-some-work","text":"$ git checkout -b edit-hello Switched to a new branch 'edit-hello' And now when we run git branch you can see we are on a different branch. $ git branch * edit-hello master","title":"Create a new branch and do some work"},{"location":"git/#edit-the-file-in-the-work-branch","text":"Now we will edit the hello.txt file in the new edit-hello branch we just created. $ sed -i 's/l/L/g' hello.txt That's the sed command. If you haven't seen it, it is a stream editor. All that command does is change every l to a L in the file. Now check the status of the repository. $ git status On branch edit-hello Changes not staged for commit: (use \"git add <file>...\" to update what will be committed) (use \"git restore <file>...\" to discard changes in working directory) modified: hello.txt no changes added to commit (use \"git add\" and/or \"git commit -a\") It says that the hello.txt file has changed. Let's check the changes now. $ git diff hello.txt diff --git a/hello.txt b/hello.txt index 4b5fa63..09d7e19 100644 --- a/hello.txt +++ b/hello.txt @@ -1 +1 @@ -hello, world +heLLo, worLd We can see that hello, world is now heLLo, worLd . That's what we wanted so now we can commit the changes.","title":"Edit the file in the work branch"},{"location":"git/#commit-the-changes-in-the-work-branch","text":"$ git add hello.txt $ git commit -m \"Swich lowercase 'l' to uppercase 'L'\" [edit-hello 27e542d] Swich lowercase 'l' to uppercase 'L' 1 file changed, 1 insertion(+), 1 deletion(-) Just double check that the git repository is clean now. $ git status On branch edit-hello nothing to commit, working tree clean","title":"Commit the changes in the work branch"},{"location":"git/#how-has-our-repository-changed","text":"So now we've done some work on the edit-hello branch, let's switch back to the master branch and see check the state of the repository. $ git checkout master Switched to branch 'master' $ git status On branch master nothing to commit, working tree clean $ cat hello.txt hello, world Whoa! The hello.txt file is the same as it was before we switched branches and did all those changes. Let's check the log. git log --pretty=oneline 8a5b9042705aff008dc396b385a3f03200e79647 (HEAD -> master) Initial commit See how that last commit isn't even listed? Let's go back to the edit-hello branch and check the log there. $ git checkout edit-hello Switched to branch 'edit-hello' $ git log --pretty=oneline 27e542d2192c3b1807f14b2460118045d549d7f5 (HEAD -> edit-hello) Swich lowercase 'l' to uppercase 'L' 8a5b9042705aff008dc396b385a3f03200e79647 (master) Initial commit Okay, both commits are still there. Notice how the commit at the top says (HEAD -> edit-hello) whereas the first commit says (master) ? This is telling you that the commits are specific to certain branches. Just to reinforce this, we will switch back to master and look at the logs again. $ git checkout master Switched to branch 'master' $ git log --pretty=oneline 8a5b9042705aff008dc396b385a3f03200e79647 (HEAD -> master) Initial commit Back to one commit with (HEAD -> master) . And one more time, back to edit-hello branch. $ git checkout edit-hello Switched to branch 'edit-hello' $ git log --pretty=oneline 27e542d2192c3b1807f14b2460118045d549d7f5 (HEAD -> edit-hello) Swich lowercase 'l' to uppercase 'L' 8a5b9042705aff008dc396b385a3f03200e79647 (master) Initial commit","title":"How has our repository changed"},{"location":"git/#what-to-do-with-the-changes","text":"Now we have two options. I like the changes in the edit-hello branch and want to make them part of the master branch. I don't like the changes in the edit-hello branch and want to forget about them.","title":"What to do with the changes?"},{"location":"git/#keep-the-changes-in-the-work-branch","text":"For the first, I need to merge the changes in the edit-hello branch into the master branch. Let's do that now. $ git branch * edit-hello master $ git checkout master Switched to branch 'master' $ git branch edit-hello * master $ git merge edit-hello Updating 8a5b904..27e542d Fast-forward hello.txt | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) $ git status On branch master nothing to commit, working tree clean $ git log --pretty=oneline 27e542d2192c3b1807f14b2460118045d549d7f5 (HEAD -> master, edit-hello) Swich lowercase 'l' to uppercase 'L' 8a5b9042705aff008dc396b385a3f03200e79647 Initial commit $ cat hello.txt heLLo, worLd See how the second commit is now in the git log and see how the hello.txt file has the changes? Since the changes are fully merged, we can safely delete the edit-hello branch. $ git branch -d edit-hello Deleted branch edit-hello (was 27e542d). $ git branch * master And now the edit-hello branch is gone.","title":"Keep the changes in the work branch"},{"location":"git/#get-rid-of-the-changes-in-the-work-branch","text":"What about the second option. Let's say we don't really like the changes of the edit-hello branch, and we just want to get rid of them. In that case we delete the branch without first merging the changes. (Note that the hash values have changed. That's because, for this tutorial, I just deleted the whole repository and started over rather than bother rolling back the changes like I would do in a real repository.) First, make sure you are on the master branch. $ git checkout master Already on 'master' $ git branch edit-hello * master Then delete the edit-hello branch. $ git branch -d edit-hello error: The branch 'edit-hello' is not fully merged. If you are sure you want to delete it, run 'git branch -D edit-hello'. See the error you got? This is because there are changes present in the edit-hello working branch that are not currently part of the master branch. So if you were to delete the edit-hello branch now, you would lose those changes with no way to get them back. Since this is actually what we want to do, we will follow the instructions on the screen and use the -D flag instead of -d to force deletion of the edit-hello branch. $ git branch -D edit-hello Deleted branch edit-hello (was cc722a5). $ git branch * master $ git log --pretty=oneline f15b723b204deb59b1f23577439ec58d917b2269 (HEAD -> master) Initial commit $ cat hello.txt hello, world As you see, we are back to the initial commit as though all of the work on the edit-hello branch never happened.","title":"Get rid of the changes in the work branch"},{"location":"git/#wrap-up","text":"Git branches are a powerful technique for isolating work in such a way that you can test things out without worrying about \"messing up\" your repository. Then, when you've finished the task you're working on, if it is good work, you can merge the changes into the master branch, or, if it was bad, you can just delete the working branch without applying any of the changes to the master branch.","title":"Wrap up"},{"location":"git/#notes","text":"Notice how I named the work branch with a short description of what I was actually planning to do? This can be helpful if you have a lot of different branches.","title":"Notes"},{"location":"installation/","text":"Installation The cln app requires you have git and git-annex installed and set-up on your computer. Additionally, if you want to build the app from source, you will need OCaml, opam, and dune. Install git and git-annex Git and git-annex are required. See the links for installation instructions. If you want to install them from source or in an specific way, check out the sites linked above. If not, you can just use the package manager. Linux You can install them with your package manager, e.g.: sudo apt-get install git git-annex . macOS You can install them with Homebrew: brew install git git-annex . Install a pre-compiled binary This is the easiest way to install the cln program. Go to the releases page on GitHub . Download the zip file for either macOS or Linux, depending on your OS. Unzip the file. It should have one file cln . Move this to somewhere on your PATH, e.g., /usr/local/bin or $HOME/.local/bin . If all goes well, you should be able to run the cln program. Try it out with cln help . Install from source Installing from source isn't too hard. The problem is that you probably don't already have OCaml installed on your computer, so you will have to install that first. *Note that you don't actually have to install from source. You can use the precompiled binaries instead. Set up OCaml First install OCaml . That guide is long, but you just need to do the parts for setting up and configuring opam. Install opam using your package manager. Initialize opam with opam init command. You may want to install the latest OCaml compiler: opam switch create 4.12.0 && eval $(opam env) . Next, install the required libraries: opam install dune core jingoo . Note that you may need to run eval $(opam env) again after this. Get the cln source code Download the source code (assuming you have git installed): git clone https://github.com/mooreryan/computational_lab_notebooks.git cd computational_lab_notebooks.git make && make install Check that the cln program is now on your path. which cln # should print out something like this: /home/ryan/.opam/4.12.0/bin/cln Set up bash completion (optional) To activate bash completions for your current shell session, source the file: . utils/cln_bash_completion.s If you want to install the bash completions (e.g., for future sessions), run: sudo make install_bash_completion This installs the bash completions to /etc/bash_completion.d . No sudo or custom completion directory If you don't have sudo or you want to install the bash completions somewhere else, you can set the BASH_COMPLETION_D environment vabiable like this: make BASH_COMPLETION_D=${HOME}/Desktop/silly_completions install_bash_completion That would install them to ${HOME}/Desktop/silly_completions . Of course, you would need to ensure that they are automatically sourced in that directory! Run tests (optional) It's always nice to run tests locally. If you have a working OCaml and Dune installation (see above), you can use make to run the tests. make test Note that, if you installed OCaml for the first time, and you haven't closed and re-opended your shell, you may still need to setup the opam environment: eval $(opam env) && make test Uninstall If you installed from source If you installed with the above procedure , you can run make uninstall && make clean to uninstall the program. If you also installed the bash completions, don't forget to delete those as well. If you installed a precompiled binary All you have to do is remove the binary! If you installed bash completions Just remove the bash completions file.","title":"Installation"},{"location":"installation/#installation","text":"The cln app requires you have git and git-annex installed and set-up on your computer. Additionally, if you want to build the app from source, you will need OCaml, opam, and dune.","title":"Installation"},{"location":"installation/#install-git-and-git-annex","text":"Git and git-annex are required. See the links for installation instructions. If you want to install them from source or in an specific way, check out the sites linked above. If not, you can just use the package manager.","title":"Install git and git-annex"},{"location":"installation/#linux","text":"You can install them with your package manager, e.g.: sudo apt-get install git git-annex .","title":"Linux"},{"location":"installation/#macos","text":"You can install them with Homebrew: brew install git git-annex .","title":"macOS"},{"location":"installation/#install-a-pre-compiled-binary","text":"This is the easiest way to install the cln program. Go to the releases page on GitHub . Download the zip file for either macOS or Linux, depending on your OS. Unzip the file. It should have one file cln . Move this to somewhere on your PATH, e.g., /usr/local/bin or $HOME/.local/bin . If all goes well, you should be able to run the cln program. Try it out with cln help .","title":"Install a pre-compiled binary"},{"location":"installation/#install-from-source","text":"Installing from source isn't too hard. The problem is that you probably don't already have OCaml installed on your computer, so you will have to install that first. *Note that you don't actually have to install from source. You can use the precompiled binaries instead.","title":"Install from source"},{"location":"installation/#set-up-ocaml","text":"First install OCaml . That guide is long, but you just need to do the parts for setting up and configuring opam. Install opam using your package manager. Initialize opam with opam init command. You may want to install the latest OCaml compiler: opam switch create 4.12.0 && eval $(opam env) . Next, install the required libraries: opam install dune core jingoo . Note that you may need to run eval $(opam env) again after this.","title":"Set up OCaml"},{"location":"installation/#get-the-cln-source-code","text":"Download the source code (assuming you have git installed): git clone https://github.com/mooreryan/computational_lab_notebooks.git cd computational_lab_notebooks.git make && make install Check that the cln program is now on your path. which cln # should print out something like this: /home/ryan/.opam/4.12.0/bin/cln","title":"Get the cln source code"},{"location":"installation/#set-up-bash-completion-optional","text":"To activate bash completions for your current shell session, source the file: . utils/cln_bash_completion.s If you want to install the bash completions (e.g., for future sessions), run: sudo make install_bash_completion This installs the bash completions to /etc/bash_completion.d .","title":"Set up bash completion (optional)"},{"location":"installation/#no-sudo-or-custom-completion-directory","text":"If you don't have sudo or you want to install the bash completions somewhere else, you can set the BASH_COMPLETION_D environment vabiable like this: make BASH_COMPLETION_D=${HOME}/Desktop/silly_completions install_bash_completion That would install them to ${HOME}/Desktop/silly_completions . Of course, you would need to ensure that they are automatically sourced in that directory!","title":"No sudo or custom completion directory"},{"location":"installation/#run-tests-optional","text":"It's always nice to run tests locally. If you have a working OCaml and Dune installation (see above), you can use make to run the tests. make test Note that, if you installed OCaml for the first time, and you haven't closed and re-opended your shell, you may still need to setup the opam environment: eval $(opam env) && make test","title":"Run tests (optional)"},{"location":"installation/#uninstall","text":"","title":"Uninstall"},{"location":"installation/#if-you-installed-from-source","text":"If you installed with the above procedure , you can run make uninstall && make clean to uninstall the program. If you also installed the bash completions, don't forget to delete those as well.","title":"If you installed from source"},{"location":"installation/#if-you-installed-a-precompiled-binary","text":"All you have to do is remove the binary!","title":"If you installed a precompiled binary"},{"location":"installation/#if-you-installed-bash-completions","text":"Just remove the bash completions file.","title":"If you installed bash completions"},{"location":"todo/","text":"To do Whoops, you hit a page that isn't finished yet! This documentation is a work in progress. If you feel as though something is missing, feel free to open an issue on the cln repository.","title":"To do"},{"location":"todo/#to-do","text":"Whoops, you hit a page that isn't finished yet! This documentation is a work in progress. If you feel as though something is missing, feel free to open an issue on the cln repository.","title":"To do"},{"location":"usage/","text":"Usage The four main commands are cln init -- initialize a new project cln prepare -- prepare an action cln run -- run an action cln remove -- remove an action Check the help screen for usage info: $ cln help Computational Lab Notebooks cln SUBCOMMAND CLI to help you manage a lab notbook with git and git-annex. === subcommands === init Initialize a new project prepare Prepare an action remove Remove a pending action run Run an action version print version information help explain a given subcommand (perhaps recursively) Initialize a new project To initialize a new project/lab notebook use cln init . The cln app is a wrapper on git and git-annex , so your project lives in a certain directory. That directory is the one in which you run the cln init command! There is nothing magical about the cln init command. It sets up the required directories, makes a README.md file, and then sets up a new git and git-annex repository. After you run cln init , you are ready to start getting some real work done! Usage To view the usage screen, run cln help init or cln init -help . $ cln help init Initialize a new project cln init PROJECT_NAME === info === Initialize a new computational lab notebook project using git and git-annex. For more info, see https://mooreryan.github.io/cln_docs/ === flags === [-help] print this help text and exit (alias: -?) Example First make a new directory and cd into it. $ mkdir my_project && cd my_project Then initialize a new project called My Project . $ cln init 'My Project' Notice how I put the My Project bit inside single quote characters ( ' )? If your project name has spaces, you need to remember to quote it! Notes If you run cln init in a directory that already has a git repository, you will get an error. Prepare an action To prepare an action or command to run, use the cln prepare command. This creates a new action file (i.e., bash script) and a git commit template in the <project_root>/.actions/pending directory. When I say \"action\", I just mean, something (e.g., a shell script) that will change the state of the repository (aka your lab notebook). The reason we formalize these things as actions is that it makes it a lot easier to figure out what happened in your project/repository a couple of months down the line when you come back to it. Usage To vier the usage screen, run cln help prepare or cln prepare -help . $ cln help prepare Prepare an action cln prepare ACTION === info === Generates an action file and a git commit template in the '<project_root>/.actions/pending' directory. For more info, see https://mooreryan.github.io/cln_docs/ === flags === [-help] print this help text and exit (alias: -?) Example Prepare a shell command to run: $ cln prepare 'echo \"hello, world\" > hello.txt' Rather than running echo \"hello, world\" > hello.txt yourself, \"preparing\" the command sets it up so that you have a way to run the command that makes it easier to remember what you did a few months/years down the line. What files were created? Action file You have the action file (aka bash script): $ cat .actions/pending/action__262765981__2021-04-09_14:54:48.sh /usr/bin/echo \"hello, world\" > hello.txt The first weird number in the file name is a hash code representing the contents of the file. The second is the date and time in which you prepared the command. Commit template And you have the git commit template. Git commit templates are a nice way to help you write good commit messages with as little annoyance as possible. $ cat .actions/pending/action__262765981__2021-04-09_14:54:48.gc_template.txt PUT COMMIT MSG HERE. == Details == PUT DETAILS HERE. == Command(s) == /usr/bin/echo \"hello, world\" > hello.txt == Action file == action__262765981__2021-04-09_14:54:48.sh Notice how the prepared action and the action file are automatically included in the commit template? This is really helpful for when you're going back searching through the commit logs. It will give you context of the exact command that was run connected with the exact changes it produced in any of the files included in your repository. After you run the action, add the changes to git and then go to actually commit the changes, you can use the commit template like this: $ git commit -t .actions/pending/action__262765981__2021-04-09_14:54:48.gc_template.txt This will open up a text editor with the contents of that file. Then you just have to edit the summary message and the details. For the summary, just put a short < 50 character explanation of what you did. For the details, try and put as much info and context as you will need to figure out what you did and why you did it. Basically, you should put the sort of things here that you would be putting in your lab notebook anyway. Notes If you try and prepare an action when there is already a pending action, you will get an error. It's set up this way to encourage you to set up a single action, run it (which then changes the state of your repository, then commit those changes to the repository. So it's like 1 action <=> 1 commit. Run an action To run an action, use the cln run command. This will look for a valid pending action, and if it finds one, runs it with bash . If it succeeds, then the program will also move the action into the <project_root>/.actions/completed directory. You will get an error if there are no pending actions. If there are more than one pending action, you will also get an error. The cln prepare command won't let you make more than one pending action. But even if you make an extra \"by-hand\" with the format exactly correct, the cln run command still won't let you run it if there are more than one. Dry run To do a \"dry run\", i.e., to have the cln prepare program just tell you what it will do without actually running any actions, you can use the -dry-run flag. Here is an example: $ cln run -dry-run You will see some useful output. Check it out and make sure it looks good. If so, then you can run the action. While the -dry-run is totally optional, I recommend that you do a dry run before running the action so you can check that you haven't made any obvious mistakes! A note on exit codes To determine wether an action has failed or succeeded, we check the exit codes. Exit code of 0 means success. Any other exit code means failure. Let's say that you prepared an action to run some bash script that you have written like this: printf \"Starting script!\\n\" ## This command will fail. cat this_file_doesnt_exist.txt > new_file.txt ## But the script will keep going and run this, which will succeed. printf \"All done!\\n\" If you ran this at the command line with bash, you would get this: $ bash silly.sh Starting script! cat: this_file_doesnt_exist.txt: No such file or directory All done! Do you think it \"succeeded\"? Let's check the exit code. $ echo $? 0 According to the exit code, yes, the script as a whole succeeded. But if you check the contents of new_file.txt you will see that it is empty, which is probably not what you wanted! So what happened is that an intermediate command failed, but given the way the script was written, the script as a whole succeeded. How to fix it This is something you will want to watch out for. If this were run as an action by cln run , the cln program would consider this program a success and move the action into the completed directory. If you have scripts like this that run lots of commands, you should consider breaking them up. That way you stick to the one action, one commit principal mentioned above. If you really want a multi-command bash script In some cases, you may need more than one command, e.g., when something only makes sense if something succeeds first. In that case, you can join the commands with && . Let's try that on the previous example. printf \"Starting script!\\n\" && \\ cat this_file_doesnt_exist.txt > new_file.txt && \\ printf \"All done!\\n\" And run that. $ bash silly2.sh Starting script! cat: this_file_doesnt_exist.txt: No such file or directory See how the last printf command was not run? Let's check the exit code again. $ echo $? 1 That's a failing exit code. So, the cln run program would consider that script to have failed. Remove an action Sometimes you need to remove pending actions: You made a mistake when prepping the action. You don't need that action anymore. There was an error when running the action. Whatever! The point is that you sometimes will want to delete actions! The way that the cln program currently works is that you can only ever have one pending action at a time. So if you have messed something up and need to get rid of the action, you will need to remove it. To do this, we use the cln remove program. Deleting, failing, or ignoring actions There are three ways to \"remove\" a pending action: Deleting it Marking it as \"failed\" (aka failing the action) Marking it as \"ignored\" (aka ignoring the action) Of these three only deleting truly deletes the action data. (And even then, if you've already checked it into your git repository you will still be able to get it back.) \"Failing\" an action means moving the action (and its associated git commit template) out of the .actions/pending directory and into the .actions/failed directory. \"Ignoring\" an action is similar to \"failing\" an action except that the pending action is moved to the .actions/ignored directory rather than the .actions/failed directory. The reason for this distinction is to help you when you're going back through your history and commit logs. I.e., it will give you more context as to why a pending action was no longer necessary. Specifying the method You specify the method you want to use with the -method flag like this Delete: cln remove -method delete Fail: cln remove -method fail Ignore: cln remove -method ignore Saving the results in the git repo After you run the cln remove command you will see some output suggesting how to proceed. You may see something like this: ~~~ * Check which files have changed: ~~~ $ git status ~~~ * Add actions and commit templates (I know it says add--it means \"track this change with git\"): ~~~ $ git add .actions ~~~ * After \"adding\" files, commit changes: ~~~ $ git commit As you can see, you still need to let git know that you have moved the actions around and commit the changes. Manually removing actions Like many of the cln commands, you could just do this \"by-hand\". Currently, the cln remove command is a pretty thin wrapper around what you would probably do by hand, but it does give you some nice messages on what you may want to do next and it does some sanity checking on your pending actions to make sure nothing has gotten crazy in the meantime.","title":"Usage"},{"location":"usage/#usage","text":"The four main commands are cln init -- initialize a new project cln prepare -- prepare an action cln run -- run an action cln remove -- remove an action Check the help screen for usage info: $ cln help Computational Lab Notebooks cln SUBCOMMAND CLI to help you manage a lab notbook with git and git-annex. === subcommands === init Initialize a new project prepare Prepare an action remove Remove a pending action run Run an action version print version information help explain a given subcommand (perhaps recursively)","title":"Usage"},{"location":"usage/#initialize-a-new-project","text":"To initialize a new project/lab notebook use cln init . The cln app is a wrapper on git and git-annex , so your project lives in a certain directory. That directory is the one in which you run the cln init command! There is nothing magical about the cln init command. It sets up the required directories, makes a README.md file, and then sets up a new git and git-annex repository. After you run cln init , you are ready to start getting some real work done!","title":"Initialize a new project"},{"location":"usage/#usage_1","text":"To view the usage screen, run cln help init or cln init -help . $ cln help init Initialize a new project cln init PROJECT_NAME === info === Initialize a new computational lab notebook project using git and git-annex. For more info, see https://mooreryan.github.io/cln_docs/ === flags === [-help] print this help text and exit (alias: -?)","title":"Usage"},{"location":"usage/#example","text":"First make a new directory and cd into it. $ mkdir my_project && cd my_project Then initialize a new project called My Project . $ cln init 'My Project' Notice how I put the My Project bit inside single quote characters ( ' )? If your project name has spaces, you need to remember to quote it!","title":"Example"},{"location":"usage/#notes","text":"If you run cln init in a directory that already has a git repository, you will get an error.","title":"Notes"},{"location":"usage/#prepare-an-action","text":"To prepare an action or command to run, use the cln prepare command. This creates a new action file (i.e., bash script) and a git commit template in the <project_root>/.actions/pending directory. When I say \"action\", I just mean, something (e.g., a shell script) that will change the state of the repository (aka your lab notebook). The reason we formalize these things as actions is that it makes it a lot easier to figure out what happened in your project/repository a couple of months down the line when you come back to it.","title":"Prepare an action"},{"location":"usage/#usage_2","text":"To vier the usage screen, run cln help prepare or cln prepare -help . $ cln help prepare Prepare an action cln prepare ACTION === info === Generates an action file and a git commit template in the '<project_root>/.actions/pending' directory. For more info, see https://mooreryan.github.io/cln_docs/ === flags === [-help] print this help text and exit (alias: -?)","title":"Usage"},{"location":"usage/#example_1","text":"Prepare a shell command to run: $ cln prepare 'echo \"hello, world\" > hello.txt' Rather than running echo \"hello, world\" > hello.txt yourself, \"preparing\" the command sets it up so that you have a way to run the command that makes it easier to remember what you did a few months/years down the line.","title":"Example"},{"location":"usage/#what-files-were-created","text":"","title":"What files were created?"},{"location":"usage/#action-file","text":"You have the action file (aka bash script): $ cat .actions/pending/action__262765981__2021-04-09_14:54:48.sh /usr/bin/echo \"hello, world\" > hello.txt The first weird number in the file name is a hash code representing the contents of the file. The second is the date and time in which you prepared the command.","title":"Action file"},{"location":"usage/#commit-template","text":"And you have the git commit template. Git commit templates are a nice way to help you write good commit messages with as little annoyance as possible. $ cat .actions/pending/action__262765981__2021-04-09_14:54:48.gc_template.txt PUT COMMIT MSG HERE. == Details == PUT DETAILS HERE. == Command(s) == /usr/bin/echo \"hello, world\" > hello.txt == Action file == action__262765981__2021-04-09_14:54:48.sh Notice how the prepared action and the action file are automatically included in the commit template? This is really helpful for when you're going back searching through the commit logs. It will give you context of the exact command that was run connected with the exact changes it produced in any of the files included in your repository. After you run the action, add the changes to git and then go to actually commit the changes, you can use the commit template like this: $ git commit -t .actions/pending/action__262765981__2021-04-09_14:54:48.gc_template.txt This will open up a text editor with the contents of that file. Then you just have to edit the summary message and the details. For the summary, just put a short < 50 character explanation of what you did. For the details, try and put as much info and context as you will need to figure out what you did and why you did it. Basically, you should put the sort of things here that you would be putting in your lab notebook anyway.","title":"Commit template"},{"location":"usage/#notes_1","text":"If you try and prepare an action when there is already a pending action, you will get an error. It's set up this way to encourage you to set up a single action, run it (which then changes the state of your repository, then commit those changes to the repository. So it's like 1 action <=> 1 commit.","title":"Notes"},{"location":"usage/#run-an-action","text":"To run an action, use the cln run command. This will look for a valid pending action, and if it finds one, runs it with bash . If it succeeds, then the program will also move the action into the <project_root>/.actions/completed directory. You will get an error if there are no pending actions. If there are more than one pending action, you will also get an error. The cln prepare command won't let you make more than one pending action. But even if you make an extra \"by-hand\" with the format exactly correct, the cln run command still won't let you run it if there are more than one.","title":"Run an action"},{"location":"usage/#dry-run","text":"To do a \"dry run\", i.e., to have the cln prepare program just tell you what it will do without actually running any actions, you can use the -dry-run flag. Here is an example: $ cln run -dry-run You will see some useful output. Check it out and make sure it looks good. If so, then you can run the action. While the -dry-run is totally optional, I recommend that you do a dry run before running the action so you can check that you haven't made any obvious mistakes!","title":"Dry run"},{"location":"usage/#a-note-on-exit-codes","text":"To determine wether an action has failed or succeeded, we check the exit codes. Exit code of 0 means success. Any other exit code means failure. Let's say that you prepared an action to run some bash script that you have written like this: printf \"Starting script!\\n\" ## This command will fail. cat this_file_doesnt_exist.txt > new_file.txt ## But the script will keep going and run this, which will succeed. printf \"All done!\\n\" If you ran this at the command line with bash, you would get this: $ bash silly.sh Starting script! cat: this_file_doesnt_exist.txt: No such file or directory All done! Do you think it \"succeeded\"? Let's check the exit code. $ echo $? 0 According to the exit code, yes, the script as a whole succeeded. But if you check the contents of new_file.txt you will see that it is empty, which is probably not what you wanted! So what happened is that an intermediate command failed, but given the way the script was written, the script as a whole succeeded.","title":"A note on exit codes"},{"location":"usage/#how-to-fix-it","text":"This is something you will want to watch out for. If this were run as an action by cln run , the cln program would consider this program a success and move the action into the completed directory. If you have scripts like this that run lots of commands, you should consider breaking them up. That way you stick to the one action, one commit principal mentioned above.","title":"How to fix it"},{"location":"usage/#if-you-really-want-a-multi-command-bash-script","text":"In some cases, you may need more than one command, e.g., when something only makes sense if something succeeds first. In that case, you can join the commands with && . Let's try that on the previous example. printf \"Starting script!\\n\" && \\ cat this_file_doesnt_exist.txt > new_file.txt && \\ printf \"All done!\\n\" And run that. $ bash silly2.sh Starting script! cat: this_file_doesnt_exist.txt: No such file or directory See how the last printf command was not run? Let's check the exit code again. $ echo $? 1 That's a failing exit code. So, the cln run program would consider that script to have failed.","title":"If you really want a multi-command bash script"},{"location":"usage/#remove-an-action","text":"Sometimes you need to remove pending actions: You made a mistake when prepping the action. You don't need that action anymore. There was an error when running the action. Whatever! The point is that you sometimes will want to delete actions! The way that the cln program currently works is that you can only ever have one pending action at a time. So if you have messed something up and need to get rid of the action, you will need to remove it. To do this, we use the cln remove program.","title":"Remove an action"},{"location":"usage/#deleting-failing-or-ignoring-actions","text":"There are three ways to \"remove\" a pending action: Deleting it Marking it as \"failed\" (aka failing the action) Marking it as \"ignored\" (aka ignoring the action) Of these three only deleting truly deletes the action data. (And even then, if you've already checked it into your git repository you will still be able to get it back.) \"Failing\" an action means moving the action (and its associated git commit template) out of the .actions/pending directory and into the .actions/failed directory. \"Ignoring\" an action is similar to \"failing\" an action except that the pending action is moved to the .actions/ignored directory rather than the .actions/failed directory. The reason for this distinction is to help you when you're going back through your history and commit logs. I.e., it will give you more context as to why a pending action was no longer necessary.","title":"Deleting, failing, or ignoring actions"},{"location":"usage/#specifying-the-method","text":"You specify the method you want to use with the -method flag like this Delete: cln remove -method delete Fail: cln remove -method fail Ignore: cln remove -method ignore","title":"Specifying the method"},{"location":"usage/#saving-the-results-in-the-git-repo","text":"After you run the cln remove command you will see some output suggesting how to proceed. You may see something like this: ~~~ * Check which files have changed: ~~~ $ git status ~~~ * Add actions and commit templates (I know it says add--it means \"track this change with git\"): ~~~ $ git add .actions ~~~ * After \"adding\" files, commit changes: ~~~ $ git commit As you can see, you still need to let git know that you have moved the actions around and commit the changes.","title":"Saving the results in the git repo"},{"location":"usage/#manually-removing-actions","text":"Like many of the cln commands, you could just do this \"by-hand\". Currently, the cln remove command is a pretty thin wrapper around what you would probably do by hand, but it does give you some nice messages on what you may want to do next and it does some sanity checking on your pending actions to make sure nothing has gotten crazy in the meantime.","title":"Manually removing actions"},{"location":"tutorials/basic_usage/","text":"Basic Usage Tutorial (Note anything starting with a $ means that is a command that you have to run at the command prompt. Anything below a command is the output of that command.) Let's walk through a simple example. We won't do anything complicated or interesting in this example, and we won't talk too much about why you would want to use this in the first place. It will be just to show you how the mechanics of using the cln app might work. Note: to read a bit more about why you might want to use the cln program, check out this blog post . I'm going to assume that you already have git , git-annex , and cln installed and ready to go. If you don't, take a look at the install page . Set up your project First thing to do is to set up a \"project\". I'm going to be calling it a project, but really it is just a directory with a git repository where you are going to do some computational lab work that you need to remeber the steps of things that you did. So make a directory for our project and cd into that directory. $ mkdir -p ~/projects/cln_example && cd ~/projects/cln_example Next, we need to initialize the project. Let's call it Example Project . $ cln init 'Example Project' You should see some output showing some stuff about initializing an empty git repository and an initial commit. The cln init program is simply a wrapper around setting up a git and git-annex repository in this directory and then commiting in some of the folders and boilerplate stuff that will be used for preparing and running jobs later. Let's see what was created. (If you don't have the tree command, you can install it like so sudo apt-get install tree ). $ tree -a -I .git . \u251c\u2500\u2500 .actions \u2502 \u251c\u2500\u2500 completed \u2502 \u251c\u2500\u2500 failed \u2502 \u251c\u2500\u2500 ignored \u2502 \u2514\u2500\u2500 pending \u2514\u2500\u2500 README.md There is a README.md file with some basic info, and a couple of folders for \"actions\". Actions are what we call things that we want to run and track in our lab notebook. You can see directories for pending, completed, failed, and ignored actions. We will talk about each of them later. Prepare a command cln prepare is used to \"prepare\" commands that you want to run. As with all of this, you don't need to use the cln program--you could just use git and git-annex directly--but going through the cln program will help you set up things to make everything a little easier to reproduce and track what is going on when you come back to your project after a couple months of working on something else. Let's set up a silly command that we want to run. We are going to use the printf command to write some text into a file. If we were to run it at the command prompt with out anything fancy it would look something like this: $ printf \"I like apple pie\\n\" > msg.txt And of course, you can check the output of that. $ cat msg.txt I like apple pie Okay, let's delete that file for now since we don't need it. $ rm msg.txt Now, preparing a command is simple. You just take whatever you were going to run at the command prompt, put that in single quotes (if you're command has single quotes, you will need to escape them), and pass that as the first argument to the cln prepare command like this: $ cln prepare 'printf \"I like apple pie\\n\" > msg.txt' ~~~ ~~~ ~~~ Hi! I just prepared an action for you. ~~~ ~~~ * The pending action is: '.actions/pending/action__460986084__2021-04-05_18:02:37.sh' ~~~ * The git commit template file is: '.actions/pending/action__460986084__2021-04-05_18:02:37.gc_template.txt' ~~~ ~~~ Next, you should check the prepared action: ~~~ $ cln run -dry-run ~~~ ~~~ You man see slightly different output than that, but the gist should be the same. As you can see, the cln prepare program created a pending action and a git commit template. (You'll see why the git commit template is helpful in a bit.) Let's take a look at those files. Pending action file $ cat '.actions/pending/action__460986084__2021-04-05_18:02:37.sh' /usr/bin/printf \"I like apple pie\\n\" > msg.txt As you see, it is just a bash script with the comman you would have run at the command prompt by hand, except with the command stuck into a little script for easy reference later. You'll see that the title of the action file has some extra info, the date the action was created and 460986084 , which is a hash of the contents. The contents hash can be helpful when you're scanning through action files to see if you've run the same commands more than once. Git commit template Now let's check out the git commit template file that was generated. $ cat '.actions/pending/action__460986084__2021-04-05_18:02:37.gc_template.txt' PUT COMMIT MSG HERE. == Details == PUT DETAILS HERE. == Command(s) == /usr/bin/printf \"I like apple pie\\n\" > msg.txt == Action file == action__460986084__2021-04-05_18:02:37.sh You can see that is has some sections in there for commit summary, details, the command that was/will be run, and the name of the action file that had the command. We will see how this helps us a bit later in the tutorial. Running pending actions Now that we have created a pending action, we want to run it. To do that, we use cln run . Preview the run Before actually running the action, it is a good idea to preview it first with the -dry-run option. $ cln run -dry-run ~~~ ~~~ ~~~ Hi! I just previewed an action for you. ~~~ ~~~ I plan to run this action file: ~~~ '.actions/pending/action__460986084__2021-04-05_18:02:37.sh' ~~~ ~~~ It's contents are: ~~~ /usr/bin/printf \"I like apple pie\\n\" > msg.txt ~~~ ~~~ If that looks good, you can run the action: ~~~ $ cln run ~~~ ~~~ You should see output similar to the above. It basically just shows you the action that will be run, and the contents of the action file. You may be wondering what happens if you have more than one pending action. Well, if you prepare actions through the cln prepare interface, you are not allowed to prepare more than one action at a time. So it won't be a problem. If you make an action file \"by hand\" outside of the cln prepare interface, and then attempt to run cln run , you will get an error about there being more than one action pending. At some point, I may add the ability to have multiple pending actions, but for now, the program forces you to set up and run one action at a time, so the accompanying git commits and their messages will be clear and have a 1-to-1 relationship with the action that was run (i.e., one action -> one commit). Alright, that action looks correct to me, so let's run it! Actually running the action To run the action, just drop the -dry-run option from the command line. $ cln run ~~~ ~~~ ~~~ Hi! I just ran an action for you. ~~~ ~~~ * The pending action was '.actions/pending/action__460986084__2021-04-05_18:02:37.sh'. ~~~ * The completed action is '.actions/completed/action__460986084__2021-04-05_18:02:37.sh'. ~~~ ~~~ Now, there are a couple of things you should do. ~~~ ~~~ * Check which files have changed: ~~~ $ git status ~~~ * Add actions and commit templates: ~~~ $ git add .actions ~~~ * Unless they are small, add other new files with git annex: ~~~ $ git annex add blah blah blah... ~~~ * After adding files, commit changes using the template: ~~~ $ git commit -t '.actions/completed/action__460986084__2021-04-05_18:02:37.gc_template.txt' ~~~ ~~~ After that you are good to go! ~~~ ~~~ * You can now check the logs with git log, ~~~ or use a GUI like gitk to view the history. ~~~ ~~~ Alright our action was successfully ran! There's a good amount of output there, so let's go through it a little bit. You will see the pending action that was run and the location of the completed action file. We keep all these action files so that, in conjuction with the git logs, you can go back later and figure out what was done. Then, you should see some suggestions of what you may want to do next. Checking git status First you want to check the git status and see what effect running the action has had on the state of your project. $ git status On branch master Untracked files: (use \"git add <file>...\" to include in what will be committed) .actions/ msg.txt nothing added to commit but untracked files present (use \"git add\" to track) (If you haven't used git before, you should probably check out a basic tutorial to get you up to speed.) Basically that is saying that some new files were created in the .actions directory and a new file called msg.txt was also created. The stuff in the .actions directory were the action and git commit template files, and the msg.txt file was what running the action actually created. Check it out. $ cat msg.txt I like apple pie Add .actions files to git repository Next, we want to add the new template and action file to the git repository. We just use git for that. This is the command to \"add\" all the changes in the .actions directory to our git repository. $ git add .actions Now if you check the status, you will see that change reflected: $ git status On branch master Changes to be committed: (use \"git restore --staged <file>...\" to unstage) new file: .actions/completed/action__460986084__2021-04-05_18:02:37.gc_template.txt new file: .actions/completed/action__460986084__2021-04-05_18:02:37.sh Untracked files: (use \"git add <file>...\" to include in what will be committed) msg.txt You see how those action and template files are now ready to be commited but the msg.txt file is still \"untracked\"? Note also that we are currently on the \"master\" branch, which is the main branch in the repository. This is mainly to keep things simple in the tutorial, but for real work, you would probably want to consider creating another branch to \"do the work\" in so that you can easily roll things back if it all goes horribly wrong. Add other files with git-annex Next, the output suggests that we add any other changed files into the repository with git-annex unless they are small. One problem with using git for your lab notebook is that it really wasn't designed to handle tracking giant files (like multi gb sequence files). For this reason, we want to use git-annex to track the large files. For this tutorial, the text file we created is really small, so we don't actually need git-annex but I will show you how to do it anyways. See the more realistic examples for more information about why you probably want to use git-annex . $ git annex add msg.txt git annex add msg.txt add msg.txt ok (recording state in git...) Again, we will talk more about git-annex in another tutorial, but basically you're now tracking the msg.txt file in your project repository. You can see for yourself with like this: $ git status On branch master Changes to be committed: (use \"git restore --staged <file>...\" to unstage) new file: .actions/completed/action__460986084__2021-04-05_18:02:37.gc_template.txt new file: .actions/completed/action__460986084__2021-04-05_18:02:37.sh new file: msg.txt See now how all the files are in the \"Changes to be commited\" section? Commiting the changes The last thing that the cln run output suggests that we do is to actually commit the changes. This will store whatever happened in the project repository's history so we can track it later. I will just copy and paste the suggusted command from the cln run output into the terminal and run it like so: $ git commit -t '.actions/completed/action__460986084__2021-04-05_18:02:37.gc_template.txt' Now you should see a text editor pop up with the following contents: PUT COMMIT MSG HERE. == Details == PUT DETAILS HERE. == Command(s) == /usr/bin/printf \"I like apple pie\\n\" > msg.txt == Action file == action__460986084__2021-04-05_18:02:37.sh # Please enter the commit message for your changes. Lines starting # with '#' will be ignored, and an empty message aborts the commit. # # On branch master # Changes to be committed: # new file: .actions/completed/action__460986084__2021-04-05_18:02:37.gc_template.txt # new file: .actions/completed/action__460986084__2021-04-05_18:02:37.sh # new file: msg.txt # All you need to do now is to fill in a short summary message at the top ( generally < 50 characters ) and then fill in some details describing what you did and why you did it. Don't skimp on the details section. Put any context you need and that you would normally put in your lab notebook about what you did (e.g., any weird command line options, why you used the program you used, why you needed to run this command, etc.). The summary and details will help you out later so make take your time and make them good! Here's an example of what it might look like for our silly printf command. Created the msg.txt file == Details == I needed to create a file that describes something that I like. I used the `printf` rather than `echo` because it is more portable. (See https://stackoverflow.com/a/11530298 for a discussion of this on stack overflow). == Command(s) == /usr/bin/printf \"I like apple pie\\n\" > msg.txt == Action file == action__460986084__2021-04-05_18:02:37.sh # Please enter the commit message for your changes. Lines starting # with '#' will be ignored, and an empty message aborts the commit. # # On branch master # Changes to be committed: # new file: .actions/completed/action__460986084__2021-04-05_18:02:37.gc_template.txt # new file: .actions/completed/action__460986084__2021-04-05_18:02:37.sh # new file: msg.txt # See how I added some details in there to help me remember why I did what I did? That's probably overkill for such a simple example, but it will be very helpful when coming back to more complicated commands in the future! After you finish writing, save it and exit your editor to complete the commit. You will probably see some git specific output on your terminal when you do. Something like this: [master ebf7385] Created the msg.txt file 3 files changed, 12 insertions(+) create mode 100644 .actions/completed/action__460986084__2021-04-05_18:02:37.gc_template.txt create mode 100644 .actions/completed/action__460986084__2021-04-05_18:02:37.sh create mode 120000 msg.txt Let's check the git status once more to make sure everything is okay. $ git status On branch master nothing to commit, working tree clean Alright, no problems! Reading the history Now that we have prepared an action, run it, and commited the resulting changes in to our project's repository, we can take a look at the changes. The simplest way to do this is with the git log command. $ git log commit ebf73855d2612ae3ddb899469994d95f2e49488e (HEAD -> master) Author: Ryan Moore <moorer@udel.edu> Date: Mon Apr 5 18:44:54 2021 -0400 Created the msg.txt file == Details == I needed to create a file that describes something that I like. I used the `printf` rather than `echo` because it is more portable. (See https://stackoverflow.com/a/11530298 for a discussion of this on stack overflow). == Command(s) == /usr/bin/printf \"I like apple pie\\n\" > msg.txt == Action file == action__460986084__2021-04-05_18:02:37.sh commit 1a2e909f2455beedeff27311d18254e9dd574f0d Author: Ryan Moore <moorer@udel.edu> Date: Mon Apr 5 17:43:50 2021 -0400 Initial commit And you will see the last commit. You can use a GUI like gitk to get a more interesting view of your commit history as well as a list of all the files and changes that occured with each of the commits. This is where it all gets really powerful. You can browse the changes in your repository one by one and see which actions were run to cause all of those changes. As you can see above, each commit is associated with the nice message template you filled out, as well as showing you which files were created and what changes occured in the repository. Very nice!! Wrap up That's most of what you need to know to get started with using cln to help you manage your computation lab notebook with git and git-annex . There are some more things to show you about deleting pending actions and using git-annex effectively, but that will be covered in other tutorials .","title":"Basic usage"},{"location":"tutorials/basic_usage/#basic-usage-tutorial","text":"(Note anything starting with a $ means that is a command that you have to run at the command prompt. Anything below a command is the output of that command.) Let's walk through a simple example. We won't do anything complicated or interesting in this example, and we won't talk too much about why you would want to use this in the first place. It will be just to show you how the mechanics of using the cln app might work. Note: to read a bit more about why you might want to use the cln program, check out this blog post . I'm going to assume that you already have git , git-annex , and cln installed and ready to go. If you don't, take a look at the install page .","title":"Basic Usage Tutorial"},{"location":"tutorials/basic_usage/#set-up-your-project","text":"First thing to do is to set up a \"project\". I'm going to be calling it a project, but really it is just a directory with a git repository where you are going to do some computational lab work that you need to remeber the steps of things that you did. So make a directory for our project and cd into that directory. $ mkdir -p ~/projects/cln_example && cd ~/projects/cln_example Next, we need to initialize the project. Let's call it Example Project . $ cln init 'Example Project' You should see some output showing some stuff about initializing an empty git repository and an initial commit. The cln init program is simply a wrapper around setting up a git and git-annex repository in this directory and then commiting in some of the folders and boilerplate stuff that will be used for preparing and running jobs later. Let's see what was created. (If you don't have the tree command, you can install it like so sudo apt-get install tree ). $ tree -a -I .git . \u251c\u2500\u2500 .actions \u2502 \u251c\u2500\u2500 completed \u2502 \u251c\u2500\u2500 failed \u2502 \u251c\u2500\u2500 ignored \u2502 \u2514\u2500\u2500 pending \u2514\u2500\u2500 README.md There is a README.md file with some basic info, and a couple of folders for \"actions\". Actions are what we call things that we want to run and track in our lab notebook. You can see directories for pending, completed, failed, and ignored actions. We will talk about each of them later.","title":"Set up your project"},{"location":"tutorials/basic_usage/#prepare-a-command","text":"cln prepare is used to \"prepare\" commands that you want to run. As with all of this, you don't need to use the cln program--you could just use git and git-annex directly--but going through the cln program will help you set up things to make everything a little easier to reproduce and track what is going on when you come back to your project after a couple months of working on something else. Let's set up a silly command that we want to run. We are going to use the printf command to write some text into a file. If we were to run it at the command prompt with out anything fancy it would look something like this: $ printf \"I like apple pie\\n\" > msg.txt And of course, you can check the output of that. $ cat msg.txt I like apple pie Okay, let's delete that file for now since we don't need it. $ rm msg.txt Now, preparing a command is simple. You just take whatever you were going to run at the command prompt, put that in single quotes (if you're command has single quotes, you will need to escape them), and pass that as the first argument to the cln prepare command like this: $ cln prepare 'printf \"I like apple pie\\n\" > msg.txt' ~~~ ~~~ ~~~ Hi! I just prepared an action for you. ~~~ ~~~ * The pending action is: '.actions/pending/action__460986084__2021-04-05_18:02:37.sh' ~~~ * The git commit template file is: '.actions/pending/action__460986084__2021-04-05_18:02:37.gc_template.txt' ~~~ ~~~ Next, you should check the prepared action: ~~~ $ cln run -dry-run ~~~ ~~~ You man see slightly different output than that, but the gist should be the same. As you can see, the cln prepare program created a pending action and a git commit template. (You'll see why the git commit template is helpful in a bit.) Let's take a look at those files.","title":"Prepare a command"},{"location":"tutorials/basic_usage/#pending-action-file","text":"$ cat '.actions/pending/action__460986084__2021-04-05_18:02:37.sh' /usr/bin/printf \"I like apple pie\\n\" > msg.txt As you see, it is just a bash script with the comman you would have run at the command prompt by hand, except with the command stuck into a little script for easy reference later. You'll see that the title of the action file has some extra info, the date the action was created and 460986084 , which is a hash of the contents. The contents hash can be helpful when you're scanning through action files to see if you've run the same commands more than once.","title":"Pending action file"},{"location":"tutorials/basic_usage/#git-commit-template","text":"Now let's check out the git commit template file that was generated. $ cat '.actions/pending/action__460986084__2021-04-05_18:02:37.gc_template.txt' PUT COMMIT MSG HERE. == Details == PUT DETAILS HERE. == Command(s) == /usr/bin/printf \"I like apple pie\\n\" > msg.txt == Action file == action__460986084__2021-04-05_18:02:37.sh You can see that is has some sections in there for commit summary, details, the command that was/will be run, and the name of the action file that had the command. We will see how this helps us a bit later in the tutorial.","title":"Git commit template"},{"location":"tutorials/basic_usage/#running-pending-actions","text":"Now that we have created a pending action, we want to run it. To do that, we use cln run .","title":"Running pending actions"},{"location":"tutorials/basic_usage/#preview-the-run","text":"Before actually running the action, it is a good idea to preview it first with the -dry-run option. $ cln run -dry-run ~~~ ~~~ ~~~ Hi! I just previewed an action for you. ~~~ ~~~ I plan to run this action file: ~~~ '.actions/pending/action__460986084__2021-04-05_18:02:37.sh' ~~~ ~~~ It's contents are: ~~~ /usr/bin/printf \"I like apple pie\\n\" > msg.txt ~~~ ~~~ If that looks good, you can run the action: ~~~ $ cln run ~~~ ~~~ You should see output similar to the above. It basically just shows you the action that will be run, and the contents of the action file. You may be wondering what happens if you have more than one pending action. Well, if you prepare actions through the cln prepare interface, you are not allowed to prepare more than one action at a time. So it won't be a problem. If you make an action file \"by hand\" outside of the cln prepare interface, and then attempt to run cln run , you will get an error about there being more than one action pending. At some point, I may add the ability to have multiple pending actions, but for now, the program forces you to set up and run one action at a time, so the accompanying git commits and their messages will be clear and have a 1-to-1 relationship with the action that was run (i.e., one action -> one commit). Alright, that action looks correct to me, so let's run it!","title":"Preview the run"},{"location":"tutorials/basic_usage/#actually-running-the-action","text":"To run the action, just drop the -dry-run option from the command line. $ cln run ~~~ ~~~ ~~~ Hi! I just ran an action for you. ~~~ ~~~ * The pending action was '.actions/pending/action__460986084__2021-04-05_18:02:37.sh'. ~~~ * The completed action is '.actions/completed/action__460986084__2021-04-05_18:02:37.sh'. ~~~ ~~~ Now, there are a couple of things you should do. ~~~ ~~~ * Check which files have changed: ~~~ $ git status ~~~ * Add actions and commit templates: ~~~ $ git add .actions ~~~ * Unless they are small, add other new files with git annex: ~~~ $ git annex add blah blah blah... ~~~ * After adding files, commit changes using the template: ~~~ $ git commit -t '.actions/completed/action__460986084__2021-04-05_18:02:37.gc_template.txt' ~~~ ~~~ After that you are good to go! ~~~ ~~~ * You can now check the logs with git log, ~~~ or use a GUI like gitk to view the history. ~~~ ~~~ Alright our action was successfully ran! There's a good amount of output there, so let's go through it a little bit. You will see the pending action that was run and the location of the completed action file. We keep all these action files so that, in conjuction with the git logs, you can go back later and figure out what was done. Then, you should see some suggestions of what you may want to do next.","title":"Actually running the action"},{"location":"tutorials/basic_usage/#checking-git-status","text":"First you want to check the git status and see what effect running the action has had on the state of your project. $ git status On branch master Untracked files: (use \"git add <file>...\" to include in what will be committed) .actions/ msg.txt nothing added to commit but untracked files present (use \"git add\" to track) (If you haven't used git before, you should probably check out a basic tutorial to get you up to speed.) Basically that is saying that some new files were created in the .actions directory and a new file called msg.txt was also created. The stuff in the .actions directory were the action and git commit template files, and the msg.txt file was what running the action actually created. Check it out. $ cat msg.txt I like apple pie","title":"Checking git status"},{"location":"tutorials/basic_usage/#add-actions-files-to-git-repository","text":"Next, we want to add the new template and action file to the git repository. We just use git for that. This is the command to \"add\" all the changes in the .actions directory to our git repository. $ git add .actions Now if you check the status, you will see that change reflected: $ git status On branch master Changes to be committed: (use \"git restore --staged <file>...\" to unstage) new file: .actions/completed/action__460986084__2021-04-05_18:02:37.gc_template.txt new file: .actions/completed/action__460986084__2021-04-05_18:02:37.sh Untracked files: (use \"git add <file>...\" to include in what will be committed) msg.txt You see how those action and template files are now ready to be commited but the msg.txt file is still \"untracked\"? Note also that we are currently on the \"master\" branch, which is the main branch in the repository. This is mainly to keep things simple in the tutorial, but for real work, you would probably want to consider creating another branch to \"do the work\" in so that you can easily roll things back if it all goes horribly wrong.","title":"Add .actions files to git repository"},{"location":"tutorials/basic_usage/#add-other-files-with-git-annex","text":"Next, the output suggests that we add any other changed files into the repository with git-annex unless they are small. One problem with using git for your lab notebook is that it really wasn't designed to handle tracking giant files (like multi gb sequence files). For this reason, we want to use git-annex to track the large files. For this tutorial, the text file we created is really small, so we don't actually need git-annex but I will show you how to do it anyways. See the more realistic examples for more information about why you probably want to use git-annex . $ git annex add msg.txt git annex add msg.txt add msg.txt ok (recording state in git...) Again, we will talk more about git-annex in another tutorial, but basically you're now tracking the msg.txt file in your project repository. You can see for yourself with like this: $ git status On branch master Changes to be committed: (use \"git restore --staged <file>...\" to unstage) new file: .actions/completed/action__460986084__2021-04-05_18:02:37.gc_template.txt new file: .actions/completed/action__460986084__2021-04-05_18:02:37.sh new file: msg.txt See now how all the files are in the \"Changes to be commited\" section?","title":"Add other files with git-annex"},{"location":"tutorials/basic_usage/#commiting-the-changes","text":"The last thing that the cln run output suggests that we do is to actually commit the changes. This will store whatever happened in the project repository's history so we can track it later. I will just copy and paste the suggusted command from the cln run output into the terminal and run it like so: $ git commit -t '.actions/completed/action__460986084__2021-04-05_18:02:37.gc_template.txt' Now you should see a text editor pop up with the following contents: PUT COMMIT MSG HERE. == Details == PUT DETAILS HERE. == Command(s) == /usr/bin/printf \"I like apple pie\\n\" > msg.txt == Action file == action__460986084__2021-04-05_18:02:37.sh # Please enter the commit message for your changes. Lines starting # with '#' will be ignored, and an empty message aborts the commit. # # On branch master # Changes to be committed: # new file: .actions/completed/action__460986084__2021-04-05_18:02:37.gc_template.txt # new file: .actions/completed/action__460986084__2021-04-05_18:02:37.sh # new file: msg.txt # All you need to do now is to fill in a short summary message at the top ( generally < 50 characters ) and then fill in some details describing what you did and why you did it. Don't skimp on the details section. Put any context you need and that you would normally put in your lab notebook about what you did (e.g., any weird command line options, why you used the program you used, why you needed to run this command, etc.). The summary and details will help you out later so make take your time and make them good! Here's an example of what it might look like for our silly printf command. Created the msg.txt file == Details == I needed to create a file that describes something that I like. I used the `printf` rather than `echo` because it is more portable. (See https://stackoverflow.com/a/11530298 for a discussion of this on stack overflow). == Command(s) == /usr/bin/printf \"I like apple pie\\n\" > msg.txt == Action file == action__460986084__2021-04-05_18:02:37.sh # Please enter the commit message for your changes. Lines starting # with '#' will be ignored, and an empty message aborts the commit. # # On branch master # Changes to be committed: # new file: .actions/completed/action__460986084__2021-04-05_18:02:37.gc_template.txt # new file: .actions/completed/action__460986084__2021-04-05_18:02:37.sh # new file: msg.txt # See how I added some details in there to help me remember why I did what I did? That's probably overkill for such a simple example, but it will be very helpful when coming back to more complicated commands in the future! After you finish writing, save it and exit your editor to complete the commit. You will probably see some git specific output on your terminal when you do. Something like this: [master ebf7385] Created the msg.txt file 3 files changed, 12 insertions(+) create mode 100644 .actions/completed/action__460986084__2021-04-05_18:02:37.gc_template.txt create mode 100644 .actions/completed/action__460986084__2021-04-05_18:02:37.sh create mode 120000 msg.txt Let's check the git status once more to make sure everything is okay. $ git status On branch master nothing to commit, working tree clean Alright, no problems!","title":"Commiting the changes"},{"location":"tutorials/basic_usage/#reading-the-history","text":"Now that we have prepared an action, run it, and commited the resulting changes in to our project's repository, we can take a look at the changes. The simplest way to do this is with the git log command. $ git log commit ebf73855d2612ae3ddb899469994d95f2e49488e (HEAD -> master) Author: Ryan Moore <moorer@udel.edu> Date: Mon Apr 5 18:44:54 2021 -0400 Created the msg.txt file == Details == I needed to create a file that describes something that I like. I used the `printf` rather than `echo` because it is more portable. (See https://stackoverflow.com/a/11530298 for a discussion of this on stack overflow). == Command(s) == /usr/bin/printf \"I like apple pie\\n\" > msg.txt == Action file == action__460986084__2021-04-05_18:02:37.sh commit 1a2e909f2455beedeff27311d18254e9dd574f0d Author: Ryan Moore <moorer@udel.edu> Date: Mon Apr 5 17:43:50 2021 -0400 Initial commit And you will see the last commit. You can use a GUI like gitk to get a more interesting view of your commit history as well as a list of all the files and changes that occured with each of the commits. This is where it all gets really powerful. You can browse the changes in your repository one by one and see which actions were run to cause all of those changes. As you can see above, each commit is associated with the nice message template you filled out, as well as showing you which files were created and what changes occured in the repository. Very nice!!","title":"Reading the history"},{"location":"tutorials/basic_usage/#wrap-up","text":"That's most of what you need to know to get started with using cln to help you manage your computation lab notebook with git and git-annex . There are some more things to show you about deleting pending actions and using git-annex effectively, but that will be covered in other tutorials .","title":"Wrap up"},{"location":"tutorials/correcting_failed_actions/","text":"Correcting failed actions In this tutorial, we will see how to handle actions that fail. Set up project First, let's set up a new project. $ mkdir silly_project && cd silly_project $ cln init 'Silly Project' Prepare failing action Now, let's set up an action that I know will fail. $ cln prepare 'printfff \"hello, world\\n\" > hello.txt' $ tree -a -I .git . \u251c\u2500\u2500 .actions \u2502 \u251c\u2500\u2500 completed \u2502 \u251c\u2500\u2500 failed \u2502 \u251c\u2500\u2500 ignored \u2502 \u2514\u2500\u2500 pending \u2502 \u251c\u2500\u2500 action__431785600__2021-04-09_18:03:59.gc_template.txt \u2502 \u2514\u2500\u2500 action__431785600__2021-04-09_18:03:59.sh \u2514\u2500\u2500 README.md See how the action is pending ? And now, we can try and run the action. Try to run the action $ cln run .actions/pending/action__60687951__2021-04-09_17:49:45.sh: line 1: printfff: command not found ERROR (code 127) when running action '.actions/pending/action__60687951__2021-04-09_17:49:45.sh' $ tree -a -I .git . \u251c\u2500\u2500 .actions \u2502 \u251c\u2500\u2500 completed \u2502 \u251c\u2500\u2500 failed \u2502 \u251c\u2500\u2500 ignored \u2502 \u2514\u2500\u2500 pending \u2502 \u251c\u2500\u2500 action__431785600__2021-04-09_18:03:59.gc_template.txt \u2502 \u2514\u2500\u2500 action__431785600__2021-04-09_18:03:59.sh \u251c\u2500\u2500 hello.txt \u2514\u2500\u2500 README.md As you see, the action failed. (You can check the error code with echo $? .) Whoops! We wrote printfff instead of printf . That should be easy enough to fix. One thing to keep in mind is that even though the command failed, the hello.txt file was still created. It is just empty. That's because the action we tried to run had the > (redirect) in there. Also, notice how the action that failed is still sitting there in the pending directory. Remove failing action Before we can prepare a new action, we have to remove the current pending action. The cln program will only let you have one pending action at a time, so we have to remove the failed action before creating a new one. To do that, use the cln remove command. Here is the help screen for that command. $ cln help remove Remove a pending action cln remove === info === If there is a pending action, this will 'remove' it. There are three ways to remove pending actions: 1) delete them, 2) move them into the ignored directory, and 3) move them into the failed directory. Use whichever one makes the most sense for why you need to remove them. For more info, see https://mooreryan.github.io/cln_docs/ === flags === -method string How to 'remove'? (delete, fail, or ignore) [-help] print this help text and exit (alias: -?) As you can see, you need to supply a method . Since the action is bad (i.e., we tried to run it and it failed), let's use the -method fail option. You could also use -method delete , but I think it is nice to keep actions that failed, as they may prove useful in the future when you return to this project in a couple of months. $ cln remove -method fail $ tree -a -I .git . \u251c\u2500\u2500 .actions \u2502 \u251c\u2500\u2500 completed \u2502 \u251c\u2500\u2500 failed \u2502 \u2502 \u251c\u2500\u2500 action__431785600__2021-04-09_18:03:59.gc_template.txt \u2502 \u2502 \u2514\u2500\u2500 action__431785600__2021-04-09_18:03:59.sh \u2502 \u251c\u2500\u2500 ignored \u2502 \u2514\u2500\u2500 pending \u251c\u2500\u2500 hello.txt \u2514\u2500\u2500 README.md The failing action (and its git commit template) are moved into the <project_root>/.actions/failed directory. Notice how that hello.txt file is still there? Track the failed action Okay, now is a good time to check the status of the git repository. $ git status On branch master Untracked files: (use \"git add <file>...\" to include in what will be committed) .actions/ hello.txt nothing added to commit but untracked files present (use \"git add\" to track) Since this is actually the first time we are commiting something other than the initial commit when we ran cln init , it shows the whole .actions directory as untracked . That's fine. We can just add the whole thing. $ git add .actions/ $ git status On branch master Changes to be committed: (use \"git restore --staged <file>...\" to unstage) new file: .actions/failed/action__431785600__2021-04-09_18:03:59.gc_template.txt new file: .actions/failed/action__431785600__2021-04-09_18:03:59.sh Untracked files: (use \"git add <file>...\" to include in what will be committed) hello.txt Note that I didn't add the hello.txt file. See how it is still marked as untracked. That's because it is just empty and not what we wanted anyway, so I won't bother checking it in to the git repo. Now, we can commit these changes with a message describing why we are putting this action in the failed actions directory: $ git commit -m \"Track a failed 'printf' action I tried to run the printf action, but I accidentally typed 'printfff' instead of 'printf', so the action failed.\" Prepare a new action And now we can make a new action that will (hopefully) succeed. $ cln prepare 'printf \"hello, world\\n\" > hello.txt' $ cln run $ tree -a -I .git . \u251c\u2500\u2500 .actions \u2502 \u251c\u2500\u2500 completed \u2502 \u2502 \u251c\u2500\u2500 action__169733033__2021-04-09_17:59:33.gc_template.txt \u2502 \u2502 \u2514\u2500\u2500 action__169733033__2021-04-09_17:59:33.sh \u2502 \u251c\u2500\u2500 failed \u2502 \u2502 \u251c\u2500\u2500 action__60687951__2021-04-09_17:49:45.gc_template.txt \u2502 \u2502 \u2514\u2500\u2500 action__60687951__2021-04-09_17:49:45.sh \u2502 \u251c\u2500\u2500 ignored \u2502 \u2514\u2500\u2500 pending \u251c\u2500\u2500 hello.txt \u2514\u2500\u2500 README.md And check the contents of hello.txt . $ cat hello.txt hello, world Track changes That's what we want. So now let's check the git status again. $ git status On branch master Untracked files: (use \"git add <file>...\" to include in what will be committed) .actions/completed/ hello.txt nothing added to commit but untracked files present (use \"git add\" to track) Since the hello.txt file is small, we can track it with git and not bother with git-annex . If it was very large, we would want to use git-annex add rather than git add . Add (aka track) all new changes. $ git add . $ git status On branch master Changes to be committed: (use \"git restore --staged <file>...\" to unstage) new file: .actions/completed/action__169733033__2021-04-09_18:30:11.gc_template.txt new file: .actions/completed/action__169733033__2021-04-09_18:30:11.sh new file: hello.txt Now we are ready for the commit. $ git commit -t Now you should see a text editor pop up with something like this: Run the 'printf' action == Details == This action creates a hello world file using the printf command. == Command(s) == /usr/bin/printf \"hello, world\\n\" > hello.txt == Action file == action__169733033__2021-04-09_18:30:11.sh # Please enter the commit message for your changes. Lines starting # with '#' will be ignored, and an empty message aborts the commit. # # On branch master # Changes to be committed: # new file: .actions/completed/action__169733033__2021-04-09_18:30:11.gc_template.txt # new file: .actions/completed/action__169733033__2021-04-09_18:30:11.sh # new file: hello.txt # Note that I changed the all caps lines to what you see above. When you finish editing the message, save and exit your editor to commit the changes with that message. Wrap up In this tutorial, we saw how to deal with actions that fail. Here's what we did: Prepare an action. Try to run it, but it fails. Remove the action with cln remove -method fail . Commit failed action to the git repo. Make a new action. Try to run it and it succeeds. Commit successful action and changes to the git repo.","title":"Correcting failed actions"},{"location":"tutorials/correcting_failed_actions/#correcting-failed-actions","text":"In this tutorial, we will see how to handle actions that fail.","title":"Correcting failed actions"},{"location":"tutorials/correcting_failed_actions/#set-up-project","text":"First, let's set up a new project. $ mkdir silly_project && cd silly_project $ cln init 'Silly Project'","title":"Set up project"},{"location":"tutorials/correcting_failed_actions/#prepare-failing-action","text":"Now, let's set up an action that I know will fail. $ cln prepare 'printfff \"hello, world\\n\" > hello.txt' $ tree -a -I .git . \u251c\u2500\u2500 .actions \u2502 \u251c\u2500\u2500 completed \u2502 \u251c\u2500\u2500 failed \u2502 \u251c\u2500\u2500 ignored \u2502 \u2514\u2500\u2500 pending \u2502 \u251c\u2500\u2500 action__431785600__2021-04-09_18:03:59.gc_template.txt \u2502 \u2514\u2500\u2500 action__431785600__2021-04-09_18:03:59.sh \u2514\u2500\u2500 README.md See how the action is pending ? And now, we can try and run the action.","title":"Prepare failing action"},{"location":"tutorials/correcting_failed_actions/#try-to-run-the-action","text":"$ cln run .actions/pending/action__60687951__2021-04-09_17:49:45.sh: line 1: printfff: command not found ERROR (code 127) when running action '.actions/pending/action__60687951__2021-04-09_17:49:45.sh' $ tree -a -I .git . \u251c\u2500\u2500 .actions \u2502 \u251c\u2500\u2500 completed \u2502 \u251c\u2500\u2500 failed \u2502 \u251c\u2500\u2500 ignored \u2502 \u2514\u2500\u2500 pending \u2502 \u251c\u2500\u2500 action__431785600__2021-04-09_18:03:59.gc_template.txt \u2502 \u2514\u2500\u2500 action__431785600__2021-04-09_18:03:59.sh \u251c\u2500\u2500 hello.txt \u2514\u2500\u2500 README.md As you see, the action failed. (You can check the error code with echo $? .) Whoops! We wrote printfff instead of printf . That should be easy enough to fix. One thing to keep in mind is that even though the command failed, the hello.txt file was still created. It is just empty. That's because the action we tried to run had the > (redirect) in there. Also, notice how the action that failed is still sitting there in the pending directory.","title":"Try to run the action"},{"location":"tutorials/correcting_failed_actions/#remove-failing-action","text":"Before we can prepare a new action, we have to remove the current pending action. The cln program will only let you have one pending action at a time, so we have to remove the failed action before creating a new one. To do that, use the cln remove command. Here is the help screen for that command. $ cln help remove Remove a pending action cln remove === info === If there is a pending action, this will 'remove' it. There are three ways to remove pending actions: 1) delete them, 2) move them into the ignored directory, and 3) move them into the failed directory. Use whichever one makes the most sense for why you need to remove them. For more info, see https://mooreryan.github.io/cln_docs/ === flags === -method string How to 'remove'? (delete, fail, or ignore) [-help] print this help text and exit (alias: -?) As you can see, you need to supply a method . Since the action is bad (i.e., we tried to run it and it failed), let's use the -method fail option. You could also use -method delete , but I think it is nice to keep actions that failed, as they may prove useful in the future when you return to this project in a couple of months. $ cln remove -method fail $ tree -a -I .git . \u251c\u2500\u2500 .actions \u2502 \u251c\u2500\u2500 completed \u2502 \u251c\u2500\u2500 failed \u2502 \u2502 \u251c\u2500\u2500 action__431785600__2021-04-09_18:03:59.gc_template.txt \u2502 \u2502 \u2514\u2500\u2500 action__431785600__2021-04-09_18:03:59.sh \u2502 \u251c\u2500\u2500 ignored \u2502 \u2514\u2500\u2500 pending \u251c\u2500\u2500 hello.txt \u2514\u2500\u2500 README.md The failing action (and its git commit template) are moved into the <project_root>/.actions/failed directory. Notice how that hello.txt file is still there?","title":"Remove failing action"},{"location":"tutorials/correcting_failed_actions/#track-the-failed-action","text":"Okay, now is a good time to check the status of the git repository. $ git status On branch master Untracked files: (use \"git add <file>...\" to include in what will be committed) .actions/ hello.txt nothing added to commit but untracked files present (use \"git add\" to track) Since this is actually the first time we are commiting something other than the initial commit when we ran cln init , it shows the whole .actions directory as untracked . That's fine. We can just add the whole thing. $ git add .actions/ $ git status On branch master Changes to be committed: (use \"git restore --staged <file>...\" to unstage) new file: .actions/failed/action__431785600__2021-04-09_18:03:59.gc_template.txt new file: .actions/failed/action__431785600__2021-04-09_18:03:59.sh Untracked files: (use \"git add <file>...\" to include in what will be committed) hello.txt Note that I didn't add the hello.txt file. See how it is still marked as untracked. That's because it is just empty and not what we wanted anyway, so I won't bother checking it in to the git repo. Now, we can commit these changes with a message describing why we are putting this action in the failed actions directory: $ git commit -m \"Track a failed 'printf' action I tried to run the printf action, but I accidentally typed 'printfff' instead of 'printf', so the action failed.\"","title":"Track the failed action"},{"location":"tutorials/correcting_failed_actions/#prepare-a-new-action","text":"And now we can make a new action that will (hopefully) succeed. $ cln prepare 'printf \"hello, world\\n\" > hello.txt' $ cln run $ tree -a -I .git . \u251c\u2500\u2500 .actions \u2502 \u251c\u2500\u2500 completed \u2502 \u2502 \u251c\u2500\u2500 action__169733033__2021-04-09_17:59:33.gc_template.txt \u2502 \u2502 \u2514\u2500\u2500 action__169733033__2021-04-09_17:59:33.sh \u2502 \u251c\u2500\u2500 failed \u2502 \u2502 \u251c\u2500\u2500 action__60687951__2021-04-09_17:49:45.gc_template.txt \u2502 \u2502 \u2514\u2500\u2500 action__60687951__2021-04-09_17:49:45.sh \u2502 \u251c\u2500\u2500 ignored \u2502 \u2514\u2500\u2500 pending \u251c\u2500\u2500 hello.txt \u2514\u2500\u2500 README.md And check the contents of hello.txt . $ cat hello.txt hello, world","title":"Prepare a new action"},{"location":"tutorials/correcting_failed_actions/#track-changes","text":"That's what we want. So now let's check the git status again. $ git status On branch master Untracked files: (use \"git add <file>...\" to include in what will be committed) .actions/completed/ hello.txt nothing added to commit but untracked files present (use \"git add\" to track) Since the hello.txt file is small, we can track it with git and not bother with git-annex . If it was very large, we would want to use git-annex add rather than git add . Add (aka track) all new changes. $ git add . $ git status On branch master Changes to be committed: (use \"git restore --staged <file>...\" to unstage) new file: .actions/completed/action__169733033__2021-04-09_18:30:11.gc_template.txt new file: .actions/completed/action__169733033__2021-04-09_18:30:11.sh new file: hello.txt Now we are ready for the commit. $ git commit -t Now you should see a text editor pop up with something like this: Run the 'printf' action == Details == This action creates a hello world file using the printf command. == Command(s) == /usr/bin/printf \"hello, world\\n\" > hello.txt == Action file == action__169733033__2021-04-09_18:30:11.sh # Please enter the commit message for your changes. Lines starting # with '#' will be ignored, and an empty message aborts the commit. # # On branch master # Changes to be committed: # new file: .actions/completed/action__169733033__2021-04-09_18:30:11.gc_template.txt # new file: .actions/completed/action__169733033__2021-04-09_18:30:11.sh # new file: hello.txt # Note that I changed the all caps lines to what you see above. When you finish editing the message, save and exit your editor to commit the changes with that message.","title":"Track changes"},{"location":"tutorials/correcting_failed_actions/#wrap-up","text":"In this tutorial, we saw how to deal with actions that fail. Here's what we did: Prepare an action. Try to run it, but it fails. Remove the action with cln remove -method fail . Commit failed action to the git repo. Make a new action. Try to run it and it succeeds. Commit successful action and changes to the git repo.","title":"Wrap up"},{"location":"tutorials/ignoring_actions/","text":"Ignoring actions Sometimes you prepare an action, only to realize that for whatever reason, you don't actually want to run the action. For a more in depth tutorial about removing actions, see the failed actions tutorial. Set up First, let's set everything up. $ mkdir silly_project && cd silly_project $ cln init 'Silly Project' Prepare an action And prepare a bogus action. $ cln prepare 'printfff \"hello, world\\n\" > hello.txt' Dry run Next, we do a dry run to see if everything looks okay. $ cln run -dry-run ~~~ ~~~ ~~~ Hi! I just previewed an action for you. ~~~ ~~~ I plan to run this action file: ~~~ '.actions/pending/action__431785600__2021-04-09_21:38:08.sh' ~~~ ~~~ It's contents are: ~~~ printfff \"hello, world\\n\" > hello.txt ~~~ ~~~ If that looks good, you can run the action: ~~~ $ cln run ~~~ ~~~ Oh no! Do you see in the preview how we made a mistake? We typed printfff instead of printf . We know this won't work so we won't even bother trying to run the action. We will just remove it. Remove action with delete method Since it is just a typing mistake, we don't really care about keeping that action around, so we will use the -method delete option to just straight delete the action. First, here is what's in the .actions directory. $ tree .actions/ .actions/ \u251c\u2500\u2500 completed \u251c\u2500\u2500 failed \u251c\u2500\u2500 ignored \u2514\u2500\u2500 pending \u251c\u2500\u2500 action__431785600__2021-04-09_21:38:08.gc_template.txt \u2514\u2500\u2500 action__431785600__2021-04-09_21:38:08.sh And now, remove the action. $ cln remove -method delete $ tree .actions .actions/ \u251c\u2500\u2500 completed \u251c\u2500\u2500 failed \u251c\u2500\u2500 ignored \u2514\u2500\u2500 pending As you see the action and the commit template are gone. Remove action with ignore method Sometimes you may need to remove an pending action, but you don't want to just delete it outright. In these cases, you can use the -method ignore option. Rather than delete the action, it will be moved from the pending directory to the ignored directory. Here is an example. $ cln prepare 'printfff \"hello, world\\n\" > hello.txt' $ tree .actions/ .actions/ \u251c\u2500\u2500 completed \u251c\u2500\u2500 failed \u251c\u2500\u2500 ignored \u2514\u2500\u2500 pending \u251c\u2500\u2500 action__431785600__2021-04-09_21:51:51.gc_template.txt \u2514\u2500\u2500 action__431785600__2021-04-09_21:51:51.sh $ cln remove -method ignore ~~~ ~~~ ~~~ Hi! I just removed a pending action for you. ~~~ ~~~ * The action is now here '.actions/ignored/action__431785600__2021-04-09_21:51:51.sh'. ~~~ * The template is now here '.actions/ignored/action__431785600__2021-04-09_21:51:51.gc_template.txt'. ~~~ ~~~ Now, there are a couple of things you should do. ~~~ ~~~ * Check which files have changed: ~~~ $ git status ~~~ * Add actions and commit templates (I know it says add--it means \"track this change with git\"): ~~~ $ git add .actions ~~~ * After \"adding\" files, commit changes: ~~~ $ git commit ~~~ ~~~ You should explain in the commit message why you needed to remove ~~~ the action. It will help you later when you're going through the ~~~ git logs! ~~~ ~~~ After that you are good to go! ~~~ ~~~ * You can now check the logs with git log, ~~~ or use a GUI like gitk to view the history. ~~~ ~~~ $ tree .actions/ .actions/ \u251c\u2500\u2500 completed \u251c\u2500\u2500 failed \u251c\u2500\u2500 ignored \u2502 \u251c\u2500\u2500 action__431785600__2021-04-09_21:51:51.gc_template.txt \u2502 \u2514\u2500\u2500 action__431785600__2021-04-09_21:51:51.sh \u2514\u2500\u2500 pending Since we used ignore rather than delete , we probably had a good reason to keep the action around even though we didn't want to run it. Maybe you typed in the wrong name for an output file, or decided that some flags you passed to the program you wanted to run needing to be changed. Regargless, if you think it is worth keeping the action, you should commit it to the lab notebook repository and put a descriptive commit message. Note that the cln remove command even suggests that you do this! $ git status $ git add .actions/ $ git status On branch master Changes to be committed: (use \"git restore --staged <file>...\" to unstage) new file: .actions/ignored/action__431785600__2021-04-09_21:51:51.gc_template.txt new file: .actions/ignored/action__431785600__2021-04-09_21:51:51.sh $ git commit -m \"Ignore the printf action For some reason, I decided it was best not to run this. Blah blah blah longish description so I remember why it is important and what I learned.\"","title":"Ignoring actions"},{"location":"tutorials/ignoring_actions/#ignoring-actions","text":"Sometimes you prepare an action, only to realize that for whatever reason, you don't actually want to run the action. For a more in depth tutorial about removing actions, see the failed actions tutorial.","title":"Ignoring actions"},{"location":"tutorials/ignoring_actions/#set-up","text":"First, let's set everything up. $ mkdir silly_project && cd silly_project $ cln init 'Silly Project'","title":"Set up"},{"location":"tutorials/ignoring_actions/#prepare-an-action","text":"And prepare a bogus action. $ cln prepare 'printfff \"hello, world\\n\" > hello.txt'","title":"Prepare an action"},{"location":"tutorials/ignoring_actions/#dry-run","text":"Next, we do a dry run to see if everything looks okay. $ cln run -dry-run ~~~ ~~~ ~~~ Hi! I just previewed an action for you. ~~~ ~~~ I plan to run this action file: ~~~ '.actions/pending/action__431785600__2021-04-09_21:38:08.sh' ~~~ ~~~ It's contents are: ~~~ printfff \"hello, world\\n\" > hello.txt ~~~ ~~~ If that looks good, you can run the action: ~~~ $ cln run ~~~ ~~~ Oh no! Do you see in the preview how we made a mistake? We typed printfff instead of printf . We know this won't work so we won't even bother trying to run the action. We will just remove it.","title":"Dry run"},{"location":"tutorials/ignoring_actions/#remove-action-with-delete-method","text":"Since it is just a typing mistake, we don't really care about keeping that action around, so we will use the -method delete option to just straight delete the action. First, here is what's in the .actions directory. $ tree .actions/ .actions/ \u251c\u2500\u2500 completed \u251c\u2500\u2500 failed \u251c\u2500\u2500 ignored \u2514\u2500\u2500 pending \u251c\u2500\u2500 action__431785600__2021-04-09_21:38:08.gc_template.txt \u2514\u2500\u2500 action__431785600__2021-04-09_21:38:08.sh And now, remove the action. $ cln remove -method delete $ tree .actions .actions/ \u251c\u2500\u2500 completed \u251c\u2500\u2500 failed \u251c\u2500\u2500 ignored \u2514\u2500\u2500 pending As you see the action and the commit template are gone.","title":"Remove action with delete method"},{"location":"tutorials/ignoring_actions/#remove-action-with-ignore-method","text":"Sometimes you may need to remove an pending action, but you don't want to just delete it outright. In these cases, you can use the -method ignore option. Rather than delete the action, it will be moved from the pending directory to the ignored directory. Here is an example. $ cln prepare 'printfff \"hello, world\\n\" > hello.txt' $ tree .actions/ .actions/ \u251c\u2500\u2500 completed \u251c\u2500\u2500 failed \u251c\u2500\u2500 ignored \u2514\u2500\u2500 pending \u251c\u2500\u2500 action__431785600__2021-04-09_21:51:51.gc_template.txt \u2514\u2500\u2500 action__431785600__2021-04-09_21:51:51.sh $ cln remove -method ignore ~~~ ~~~ ~~~ Hi! I just removed a pending action for you. ~~~ ~~~ * The action is now here '.actions/ignored/action__431785600__2021-04-09_21:51:51.sh'. ~~~ * The template is now here '.actions/ignored/action__431785600__2021-04-09_21:51:51.gc_template.txt'. ~~~ ~~~ Now, there are a couple of things you should do. ~~~ ~~~ * Check which files have changed: ~~~ $ git status ~~~ * Add actions and commit templates (I know it says add--it means \"track this change with git\"): ~~~ $ git add .actions ~~~ * After \"adding\" files, commit changes: ~~~ $ git commit ~~~ ~~~ You should explain in the commit message why you needed to remove ~~~ the action. It will help you later when you're going through the ~~~ git logs! ~~~ ~~~ After that you are good to go! ~~~ ~~~ * You can now check the logs with git log, ~~~ or use a GUI like gitk to view the history. ~~~ ~~~ $ tree .actions/ .actions/ \u251c\u2500\u2500 completed \u251c\u2500\u2500 failed \u251c\u2500\u2500 ignored \u2502 \u251c\u2500\u2500 action__431785600__2021-04-09_21:51:51.gc_template.txt \u2502 \u2514\u2500\u2500 action__431785600__2021-04-09_21:51:51.sh \u2514\u2500\u2500 pending Since we used ignore rather than delete , we probably had a good reason to keep the action around even though we didn't want to run it. Maybe you typed in the wrong name for an output file, or decided that some flags you passed to the program you wanted to run needing to be changed. Regargless, if you think it is worth keeping the action, you should commit it to the lab notebook repository and put a descriptive commit message. Note that the cln remove command even suggests that you do this! $ git status $ git add .actions/ $ git status On branch master Changes to be committed: (use \"git restore --staged <file>...\" to unstage) new file: .actions/ignored/action__431785600__2021-04-09_21:51:51.gc_template.txt new file: .actions/ignored/action__431785600__2021-04-09_21:51:51.sh $ git commit -m \"Ignore the printf action For some reason, I decided it was best not to run this. Blah blah blah longish description so I remember why it is important and what I learned.\"","title":"Remove action with ignore method"},{"location":"tutorials/overview/","text":"Examples & Tutorials In this section, we will go over a couple of tutorials to help you get a feel for using the cln app to manage your computational lab notebooks. Cram tests If you are feeling very brave, you can get always up-to-date examples by looking at the cram tests in <project root>/tests/cram . The *.t files are cram tests. They look a bit weird at first but the walk through different scenarios of using the cln CLI app. They are guaranteed to be up to date with whatever version of the code you're running since they are integration tests!","title":"Overview"},{"location":"tutorials/overview/#examples-tutorials","text":"In this section, we will go over a couple of tutorials to help you get a feel for using the cln app to manage your computational lab notebooks.","title":"Examples &amp; Tutorials"},{"location":"tutorials/overview/#cram-tests","text":"If you are feeling very brave, you can get always up-to-date examples by looking at the cram tests in <project root>/tests/cram . The *.t files are cram tests. They look a bit weird at first but the walk through different scenarios of using the cln CLI app. They are guaranteed to be up to date with whatever version of the code you're running since they are integration tests!","title":"Cram tests"}]}